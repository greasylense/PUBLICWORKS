<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>Breath — PUBLICWORKS</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Space+Grotesk:wght@700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg: #D1D1D1;
      --primary: #0F0F0F;
      --secondary: #6E6E6E;
      --accent: #0047FF;
      --warm: #FF4D00;
    }

    body {
      background: var(--bg);
      font-family: 'IBM Plex Mono', monospace;
      color: var(--primary);
      min-height: 100vh;
      overflow: hidden;
      -webkit-user-select: none;
      user-select: none;
    }

    /* Back link */
    #back-link {
      position: fixed;
      top: 2rem;
      left: 2rem;
      font-size: 0.75rem;
      color: var(--secondary);
      text-decoration: none;
      z-index: 100;
      transition: color 0.15s ease;
    }

    #back-link:hover {
      color: var(--accent);
    }

    /* Mode Selection Screen */
    #mode-select {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }

    #mode-select.hidden {
      opacity: 0;
      visibility: hidden;
      pointer-events: none;
    }

    #mode-select h1 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: clamp(2rem, 8vw, 4rem);
      font-weight: 700;
      letter-spacing: -0.03em;
      margin-bottom: 3rem;
    }

    .modes-grid {
      display: flex;
      flex-direction: column;
      gap: 1rem;
      max-width: 400px;
      width: 100%;
    }

    .mode-btn {
      background: transparent;
      border: 1px solid var(--secondary);
      padding: 1.25rem 1.5rem;
      text-align: left;
      cursor: pointer;
      transition: all 0.2s ease;
      position: relative;
    }

    .mode-btn:hover {
      border-color: var(--primary);
      background: rgba(0, 0, 0, 0.03);
    }

    .mode-btn:hover .mode-name {
      color: var(--accent);
    }

    .mode-name {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.125rem;
      font-weight: 700;
      margin-bottom: 0.25rem;
      transition: color 0.2s ease;
    }

    .mode-desc {
      font-size: 0.75rem;
      color: var(--secondary);
    }

    .mode-timing {
      position: absolute;
      top: 1.25rem;
      right: 1.5rem;
      font-size: 0.625rem;
      color: var(--secondary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* Info button */
    .info-btn {
      position: absolute;
      bottom: 1.25rem;
      right: 1.5rem;
      width: 1.25rem;
      height: 1.25rem;
      border: 1px solid var(--secondary);
      border-radius: 50%;
      background: transparent;
      color: var(--secondary);
      font-size: 0.625rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s ease;
    }

    .info-btn:hover {
      border-color: var(--accent);
      color: var(--accent);
    }

    /* Info Panel */
    #info-panel {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--primary);
      color: var(--bg);
      padding: 2rem;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 200;
      max-height: 50vh;
      overflow-y: auto;
    }

    #info-panel.visible {
      transform: translateY(0);
    }

    #info-panel h3 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.25rem;
      margin-bottom: 1rem;
    }

    #info-panel p {
      font-size: 0.8125rem;
      line-height: 1.6;
      color: rgba(209, 209, 209, 0.8);
      max-width: 600px;
    }

    #info-panel .close-info {
      position: absolute;
      top: 1.5rem;
      right: 1.5rem;
      background: none;
      border: none;
      color: var(--bg);
      font-size: 1.5rem;
      cursor: pointer;
      opacity: 0.6;
      transition: opacity 0.2s ease;
    }

    #info-panel .close-info:hover {
      opacity: 1;
    }

    /* Session Screen */
    #session {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease, visibility 0.5s ease;
    }

    #session.active {
      opacity: 1;
      visibility: visible;
    }

    /* Visual Canvas */
    #visual {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }

    /* Phase Label */
    #phase-label {
      position: relative;
      z-index: 10;
      font-size: 0.875rem;
      color: var(--secondary);
      text-transform: lowercase;
      letter-spacing: 0.1em;
      margin-top: 2rem;
      transition: opacity 0.3s ease;
    }

    /* Countdown */
    #countdown {
      position: relative;
      z-index: 10;
      font-family: 'Space Grotesk', sans-serif;
      font-size: 4rem;
      font-weight: 700;
      color: var(--primary);
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #countdown.visible {
      opacity: 1;
    }

    /* Session Info */
    #session-info {
      position: fixed;
      bottom: 2rem;
      left: 2rem;
      font-size: 0.75rem;
      color: var(--secondary);
      z-index: 10;
    }

    #cycle-count {
      margin-bottom: 0.25rem;
    }

    /* Pause/Exit Controls */
    #controls {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      display: flex;
      gap: 1rem;
      z-index: 10;
    }

    .control-btn {
      background: transparent;
      border: 1px solid var(--secondary);
      padding: 0.5rem 1rem;
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.625rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      color: var(--secondary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .control-btn:hover {
      border-color: var(--primary);
      color: var(--primary);
    }

    /* Paused State */
    #paused-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(209, 209, 209, 0.9);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 50;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    #paused-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    #paused-overlay span {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 1.5rem;
      color: var(--primary);
    }

    /* Wim Hof specific */
    #hold-timer {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 3rem;
      font-weight: 700;
      color: var(--accent);
      position: relative;
      z-index: 10;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    #hold-timer.visible {
      opacity: 1;
    }

    /* Complete Screen */
    #complete {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.5s ease, visibility 0.5s ease;
      z-index: 60;
    }

    #complete.visible {
      opacity: 1;
      visibility: visible;
    }

    #complete h2 {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 2rem;
      margin-bottom: 2rem;
    }

    #complete .complete-btns {
      display: flex;
      gap: 1rem;
    }

    /* Pre-session countdown */
    #pre-countdown {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      z-index: 70;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
    }

    #pre-countdown.visible {
      opacity: 1;
      visibility: visible;
    }

    #pre-countdown .count {
      font-family: 'Space Grotesk', sans-serif;
      font-size: 6rem;
      font-weight: 700;
      color: var(--primary);
    }

    #pre-countdown .mode-name-display {
      font-size: 0.875rem;
      color: var(--secondary);
      text-transform: uppercase;
      letter-spacing: 0.1em;
      margin-bottom: 2rem;
    }

    /* Mobile adjustments */
    @media (max-width: 600px) {
      #back-link {
        top: 1rem;
        left: 1rem;
      }

      .modes-grid {
        padding: 0 1rem;
      }

      #session-info {
        bottom: 1rem;
        left: 1rem;
      }

      #controls {
        bottom: 1rem;
        right: 1rem;
      }
    }
  </style>
</head>
<body>
  <a href="../../" id="back-link">← PUBLICWORKS</a>

  <!-- Mode Selection -->
  <div id="mode-select">
    <h1>Breath</h1>
    <div class="modes-grid">
      <button class="mode-btn" data-mode="box">
        <div class="mode-name">Box Breathing</div>
        <div class="mode-desc">Calm anxiety, focus, stress relief</div>
        <div class="mode-timing">4-4-4-4</div>
        <button class="info-btn" data-info="box">i</button>
      </button>
      <button class="mode-btn" data-mode="relaxation">
        <div class="mode-name">4-7-8 Relaxation</div>
        <div class="mode-desc">Sleep, deep relaxation</div>
        <div class="mode-timing">4-7-8</div>
        <button class="info-btn" data-info="relaxation">i</button>
      </button>
      <button class="mode-btn" data-mode="wimhof">
        <div class="mode-name">Wim Hof Method</div>
        <div class="mode-desc">Energy, mental clarity</div>
        <div class="mode-timing">30 breaths + hold</div>
        <button class="info-btn" data-info="wimhof">i</button>
      </button>
      <button class="mode-btn" data-mode="sigh">
        <div class="mode-name">Physiological Sigh</div>
        <div class="mode-desc">Instant calm, 30-second reset</div>
        <div class="mode-timing">double inhale</div>
        <button class="info-btn" data-info="sigh">i</button>
      </button>
      <button class="mode-btn" data-mode="equal">
        <div class="mode-name">Equal Breathing</div>
        <div class="mode-desc">Balance, meditation prep</div>
        <div class="mode-timing">4-4</div>
        <button class="info-btn" data-info="equal">i</button>
      </button>
    </div>
  </div>

  <!-- Info Panel -->
  <div id="info-panel">
    <button class="close-info">&times;</button>
    <h3 id="info-title"></h3>
    <p id="info-text"></p>
  </div>

  <!-- Pre-session Countdown -->
  <div id="pre-countdown">
    <div class="mode-name-display"></div>
    <div class="count">3</div>
  </div>

  <!-- Session -->
  <div id="session">
    <canvas id="visual"></canvas>
    <div id="countdown"></div>
    <div id="hold-timer"></div>
    <p id="phase-label">inhale</p>
    <div id="session-info">
      <div id="cycle-count"></div>
      <div id="current-mode"></div>
    </div>
    <div id="controls">
      <button class="control-btn" id="pause-btn">Pause</button>
      <button class="control-btn" id="exit-btn">Exit</button>
    </div>
  </div>

  <!-- Paused Overlay -->
  <div id="paused-overlay">
    <span>paused — tap to resume</span>
  </div>

  <!-- Complete Screen -->
  <div id="complete">
    <h2>Session Complete</h2>
    <div class="complete-btns">
      <button class="control-btn" id="repeat-btn">Repeat</button>
      <button class="control-btn" id="new-btn">New Mode</button>
    </div>
  </div>

  <script>
    (function() {
      'use strict';

      // ---------- Breathing Patterns ----------
      const patterns = {
        box: {
          name: 'Box Breathing',
          phases: [
            { name: 'inhale', duration: 4 },
            { name: 'hold', duration: 4 },
            { name: 'exhale', duration: 4 },
            { name: 'hold', duration: 4 }
          ],
          cycles: 8,
          visual: 'square'
        },
        relaxation: {
          name: '4-7-8 Relaxation',
          phases: [
            { name: 'inhale', duration: 4 },
            { name: 'hold', duration: 7 },
            { name: 'exhale', duration: 8 }
          ],
          cycles: 4,
          visual: 'circle'
        },
        wimhof: {
          name: 'Wim Hof Method',
          type: 'wimhof',
          breathCount: 30,
          recoveryHold: 15,
          rounds: 3,
          visual: 'pulse'
        },
        sigh: {
          name: 'Physiological Sigh',
          phases: [
            { name: 'inhale', duration: 2 },
            { name: 'inhale', duration: 1 },
            { name: 'exhale', duration: 6 }
          ],
          cycles: 3,
          visual: 'wave'
        },
        equal: {
          name: 'Equal Breathing',
          phases: [
            { name: 'inhale', duration: 4 },
            { name: 'exhale', duration: 4 }
          ],
          cycles: 10,
          visual: 'pendulum'
        }
      };

      // ---------- Info Content ----------
      const infoContent = {
        box: {
          title: 'Box Breathing',
          text: 'Used by Navy SEALs to stay calm under pressure. This technique activates the parasympathetic nervous system, reducing stress hormones and lowering heart rate. Equal duration for each phase creates a balanced, grounding rhythm.'
        },
        relaxation: {
          title: '4-7-8 Relaxation',
          text: 'Developed by Dr. Andrew Weil, based on ancient yogic breathing. Acts as a natural tranquilizer for the nervous system. The extended exhale and hold activate the vagus nerve, promoting deep relaxation. Best used before sleep.'
        },
        wimhof: {
          title: 'Wim Hof Method',
          text: 'Created by "The Iceman" Wim Hof. Combines controlled hyperventilation with breath retention. Temporarily increases blood oxygen and pH, creating a controlled stress response. Often paired with cold exposure for enhanced benefits.'
        },
        sigh: {
          title: 'Physiological Sigh',
          text: 'Discovered by Stanford neuroscientist Andrew Huberman. The double inhale maximally inflates the lungs and pops open collapsed air sacs, while the long exhale offloads carbon dioxide. The fastest known method to reduce real-time stress.'
        },
        equal: {
          title: 'Equal Breathing (Sama Vritti)',
          text: 'An ancient yogic technique meaning "same fluctuation." Balancing inhale and exhale duration calms both branches of the autonomic nervous system. Excellent for meditation preparation or general daily stress management.'
        }
      };

      // ---------- DOM Elements ----------
      const modeSelect = document.getElementById('mode-select');
      const session = document.getElementById('session');
      const canvas = document.getElementById('visual');
      const ctx = canvas.getContext('2d');
      const phaseLabel = document.getElementById('phase-label');
      const cycleCount = document.getElementById('cycle-count');
      const currentModeEl = document.getElementById('current-mode');
      const pauseBtn = document.getElementById('pause-btn');
      const exitBtn = document.getElementById('exit-btn');
      const pausedOverlay = document.getElementById('paused-overlay');
      const preCountdown = document.getElementById('pre-countdown');
      const countdown = document.getElementById('countdown');
      const holdTimer = document.getElementById('hold-timer');
      const complete = document.getElementById('complete');
      const repeatBtn = document.getElementById('repeat-btn');
      const newBtn = document.getElementById('new-btn');
      const infoPanel = document.getElementById('info-panel');
      const infoTitle = document.getElementById('info-title');
      const infoText = document.getElementById('info-text');
      const closeInfo = document.querySelector('.close-info');

      // ---------- State ----------
      let currentMode = null;
      let currentPattern = null;
      let isRunning = false;
      let isPaused = false;
      let animationId = null;
      let phaseIndex = 0;
      let cycleIndex = 0;
      let phaseStartTime = 0;
      let phaseDuration = 0;
      let phaseProgress = 0;

      // Wim Hof specific state
      let wimhofPhase = 'breathing'; // 'breathing', 'hold', 'recovery'
      let breathCount = 0;
      let holdStartTime = 0;
      let roundIndex = 0;

      // Canvas dimensions
      let width, height, centerX, centerY;

      // ---------- Canvas Setup ----------
      function resizeCanvas() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        centerX = width / 2;
        centerY = height / 2;
      }

      // ---------- Visual Renderers ----------
      const visuals = {
        // Box Breathing - Square that draws itself
        square: function(progress, phase) {
          const size = Math.min(width, height) * 0.35;
          const halfSize = size / 2;

          ctx.strokeStyle = '#0F0F0F';
          ctx.lineWidth = 2;
          ctx.lineCap = 'round';

          // Draw base square faintly
          ctx.globalAlpha = 0.1;
          ctx.strokeRect(centerX - halfSize, centerY - halfSize, size, size);
          ctx.globalAlpha = 1;

          // Draw progress along square edge
          ctx.beginPath();
          const totalPhases = currentPattern.phases.length;
          const phaseLength = size;

          // Calculate total progress through all phases
          const completedPhases = phaseIndex;
          const overallProgress = (completedPhases + progress) / totalPhases;
          const totalLength = size * 4;
          const drawLength = overallProgress * totalLength;

          // Start at top-left, go clockwise
          let remaining = drawLength;
          let x = centerX - halfSize;
          let y = centerY - halfSize;

          ctx.moveTo(x, y);

          // Top edge (right)
          if (remaining > 0) {
            const segmentLength = Math.min(remaining, size);
            ctx.lineTo(x + segmentLength, y);
            remaining -= segmentLength;
          }

          // Right edge (down)
          if (remaining > 0) {
            const segmentLength = Math.min(remaining, size);
            ctx.lineTo(centerX + halfSize, y + segmentLength);
            remaining -= segmentLength;
          }

          // Bottom edge (left)
          if (remaining > 0) {
            const segmentLength = Math.min(remaining, size);
            ctx.lineTo(centerX + halfSize - segmentLength, centerY + halfSize);
            remaining -= segmentLength;
          }

          // Left edge (up)
          if (remaining > 0) {
            const segmentLength = Math.min(remaining, size);
            ctx.lineTo(centerX - halfSize, centerY + halfSize - segmentLength);
          }

          ctx.strokeStyle = phase === 'hold' ? '#0047FF' : '#0F0F0F';
          ctx.stroke();

          // Draw current position indicator
          let indicatorX, indicatorY;
          const currentPhaseProgress = progress;

          if (phaseIndex === 0) { // Top edge
            indicatorX = centerX - halfSize + size * currentPhaseProgress;
            indicatorY = centerY - halfSize;
          } else if (phaseIndex === 1) { // Right edge
            indicatorX = centerX + halfSize;
            indicatorY = centerY - halfSize + size * currentPhaseProgress;
          } else if (phaseIndex === 2) { // Bottom edge
            indicatorX = centerX + halfSize - size * currentPhaseProgress;
            indicatorY = centerY + halfSize;
          } else { // Left edge
            indicatorX = centerX - halfSize;
            indicatorY = centerY + halfSize - size * currentPhaseProgress;
          }

          ctx.beginPath();
          ctx.arc(indicatorX, indicatorY, 6, 0, Math.PI * 2);
          ctx.fillStyle = '#0047FF';
          ctx.fill();
        },

        // 4-7-8 - Expanding/contracting circle
        circle: function(progress, phase) {
          const maxRadius = Math.min(width, height) * 0.3;
          const minRadius = maxRadius * 0.3;

          let radius;
          let alpha = 1;

          if (phase === 'inhale') {
            radius = minRadius + (maxRadius - minRadius) * easeInOutCubic(progress);
          } else if (phase === 'hold') {
            radius = maxRadius;
            // Subtle pulse during hold
            const pulse = Math.sin(progress * Math.PI * 4) * 0.02;
            radius = maxRadius * (1 + pulse);
            alpha = 0.8 + Math.sin(progress * Math.PI * 2) * 0.2;
          } else {
            radius = maxRadius - (maxRadius - minRadius) * easeInOutCubic(progress);
          }

          // Outer glow
          const gradient = ctx.createRadialGradient(centerX, centerY, radius * 0.8, centerX, centerY, radius * 1.2);
          gradient.addColorStop(0, 'rgba(0, 71, 255, 0.1)');
          gradient.addColorStop(1, 'rgba(0, 71, 255, 0)');
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius * 1.2, 0, Math.PI * 2);
          ctx.fill();

          // Main circle
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
          ctx.strokeStyle = phase === 'hold' ? `rgba(0, 71, 255, ${alpha})` : `rgba(15, 15, 15, ${alpha})`;
          ctx.lineWidth = 2;
          ctx.stroke();

          // Inner circle
          ctx.beginPath();
          ctx.arc(centerX, centerY, radius * 0.3, 0, Math.PI * 2);
          ctx.fillStyle = phase === 'hold' ? 'rgba(0, 71, 255, 0.1)' : 'rgba(15, 15, 15, 0.05)';
          ctx.fill();
        },

        // Wim Hof - Pulsing rhythm
        pulse: function(progress, phase) {
          const maxRadius = Math.min(width, height) * 0.35;

          if (wimhofPhase === 'breathing') {
            // Rapid pulsing during breathing phase
            const pulseProgress = progress;
            const radius = maxRadius * (0.5 + 0.5 * Math.sin(pulseProgress * Math.PI));

            // Multiple concentric rings
            for (let i = 0; i < 3; i++) {
              const ringRadius = radius * (1 - i * 0.2);
              const alpha = 1 - i * 0.3;

              ctx.beginPath();
              ctx.arc(centerX, centerY, ringRadius, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(15, 15, 15, ${alpha})`;
              ctx.lineWidth = 2 - i * 0.5;
              ctx.stroke();
            }

            // Breath count indicator
            const countRadius = maxRadius * 1.2;
            const angleStep = (Math.PI * 2) / currentPattern.breathCount;
            for (let i = 0; i < currentPattern.breathCount; i++) {
              const angle = -Math.PI / 2 + i * angleStep;
              const x = centerX + Math.cos(angle) * countRadius;
              const y = centerY + Math.sin(angle) * countRadius;

              ctx.beginPath();
              ctx.arc(x, y, 3, 0, Math.PI * 2);
              ctx.fillStyle = i < breathCount ? '#0047FF' : 'rgba(15, 15, 15, 0.2)';
              ctx.fill();
            }
          } else if (wimhofPhase === 'hold') {
            // Stillness with subtle glow
            const glowIntensity = 0.3 + Math.sin(Date.now() / 1000) * 0.1;

            const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, maxRadius);
            gradient.addColorStop(0, `rgba(0, 71, 255, ${glowIntensity})`);
            gradient.addColorStop(1, 'rgba(0, 71, 255, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius, 0, Math.PI * 2);
            ctx.fill();

            ctx.beginPath();
            ctx.arc(centerX, centerY, maxRadius * 0.5, 0, Math.PI * 2);
            ctx.strokeStyle = '#0047FF';
            ctx.lineWidth = 2;
            ctx.stroke();
          } else {
            // Recovery breath
            const radius = maxRadius * (0.3 + 0.7 * easeInOutCubic(progress));

            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
            ctx.strokeStyle = '#FF4D00';
            ctx.lineWidth = 3;
            ctx.stroke();
          }
        },

        // Physiological Sigh - Wave pattern
        wave: function(progress, phase) {
          const amplitude = Math.min(width, height) * 0.15;
          const lineY = centerY;

          ctx.beginPath();
          ctx.moveTo(0, lineY);

          // Calculate wave height based on phase
          let waveHeight;
          if (phaseIndex === 0) { // First inhale
            waveHeight = -amplitude * 0.7 * easeOutCubic(progress);
          } else if (phaseIndex === 1) { // Second inhale (top off)
            waveHeight = -amplitude * (0.7 + 0.3 * easeOutCubic(progress));
          } else { // Long exhale
            waveHeight = -amplitude * (1 - easeInOutCubic(progress));
          }

          // Draw wave
          for (let x = 0; x <= width; x += 5) {
            const distFromCenter = Math.abs(x - centerX) / (width / 2);
            const falloff = 1 - distFromCenter * distFromCenter;
            const y = lineY + waveHeight * falloff * Math.cos((x - centerX) / 100);
            ctx.lineTo(x, y);
          }

          ctx.strokeStyle = phase === 'exhale' ? '#0047FF' : '#0F0F0F';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Peak indicator
          ctx.beginPath();
          ctx.arc(centerX, lineY + waveHeight, 6, 0, Math.PI * 2);
          ctx.fillStyle = '#0047FF';
          ctx.fill();
        },

        // Equal Breathing - Pendulum
        pendulum: function(progress, phase) {
          const maxAngle = Math.PI / 4;
          const length = Math.min(width, height) * 0.35;
          const pivotY = centerY - length * 0.3;

          // Calculate angle based on phase
          let angle;
          if (phase === 'inhale') {
            angle = -maxAngle + maxAngle * 2 * easeInOutSine(progress);
          } else {
            angle = maxAngle - maxAngle * 2 * easeInOutSine(progress);
          }

          const bobX = centerX + Math.sin(angle) * length;
          const bobY = pivotY + Math.cos(angle) * length;

          // Draw arc path (faint)
          ctx.beginPath();
          ctx.arc(centerX, pivotY, length, Math.PI / 2 - maxAngle, Math.PI / 2 + maxAngle);
          ctx.strokeStyle = 'rgba(15, 15, 15, 0.1)';
          ctx.lineWidth = 1;
          ctx.stroke();

          // Draw pendulum line
          ctx.beginPath();
          ctx.moveTo(centerX, pivotY);
          ctx.lineTo(bobX, bobY);
          ctx.strokeStyle = '#0F0F0F';
          ctx.lineWidth = 2;
          ctx.stroke();

          // Draw pivot
          ctx.beginPath();
          ctx.arc(centerX, pivotY, 4, 0, Math.PI * 2);
          ctx.fillStyle = '#6E6E6E';
          ctx.fill();

          // Draw bob
          ctx.beginPath();
          ctx.arc(bobX, bobY, 12, 0, Math.PI * 2);
          ctx.fillStyle = '#0047FF';
          ctx.fill();
        }
      };

      // ---------- Easing Functions ----------
      function easeInOutCubic(t) {
        return t < 0.5 ? 4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;
      }

      function easeOutCubic(t) {
        return 1 - Math.pow(1 - t, 3);
      }

      function easeInOutSine(t) {
        return -(Math.cos(Math.PI * t) - 1) / 2;
      }

      // ---------- Session Logic ----------
      function startSession(mode) {
        currentMode = mode;
        currentPattern = patterns[mode];

        // Reset state
        phaseIndex = 0;
        cycleIndex = 0;
        breathCount = 0;
        roundIndex = 0;
        wimhofPhase = 'breathing';
        isPaused = false;

        // Show pre-countdown
        preCountdown.querySelector('.mode-name-display').textContent = currentPattern.name;
        preCountdown.classList.add('visible');

        let count = 3;
        preCountdown.querySelector('.count').textContent = count;

        const countInterval = setInterval(() => {
          count--;
          if (count > 0) {
            preCountdown.querySelector('.count').textContent = count;
          } else {
            clearInterval(countInterval);
            preCountdown.classList.remove('visible');
            beginSession();
          }
        }, 1000);
      }

      function beginSession() {
        modeSelect.classList.add('hidden');
        session.classList.add('active');
        currentModeEl.textContent = currentPattern.name;

        isRunning = true;

        if (currentPattern.type === 'wimhof') {
          startWimHofBreathing();
        } else {
          startPhase();
        }

        animate();
      }

      function startPhase() {
        const phase = currentPattern.phases[phaseIndex];
        phaseDuration = phase.duration * 1000;
        phaseStartTime = Date.now();
        phaseLabel.textContent = phase.name;
        updateCycleDisplay();
      }

      function updateCycleDisplay() {
        if (currentPattern.type === 'wimhof') {
          cycleCount.textContent = `Round ${roundIndex + 1}/${currentPattern.rounds}`;
        } else {
          cycleCount.textContent = `Cycle ${cycleIndex + 1}/${currentPattern.cycles}`;
        }
      }

      function nextPhase() {
        phaseIndex++;

        if (phaseIndex >= currentPattern.phases.length) {
          phaseIndex = 0;
          cycleIndex++;

          if (cycleIndex >= currentPattern.cycles) {
            endSession();
            return;
          }
        }

        startPhase();
      }

      // ---------- Wim Hof Specific Logic ----------
      function startWimHofBreathing() {
        wimhofPhase = 'breathing';
        breathCount = 0;
        phaseLabel.textContent = 'breathe deeply';
        updateCycleDisplay();

        // Rapid breathing cycle
        doWimHofBreath();
      }

      function doWimHofBreath() {
        if (!isRunning || isPaused) return;

        if (breathCount >= currentPattern.breathCount) {
          startWimHofHold();
          return;
        }

        phaseStartTime = Date.now();
        phaseDuration = 1500; // 1.5 seconds per breath

        setTimeout(() => {
          if (!isRunning || isPaused) return;
          breathCount++;
          doWimHofBreath();
        }, 1500);
      }

      function startWimHofHold() {
        wimhofPhase = 'hold';
        holdStartTime = Date.now();
        phaseLabel.textContent = 'hold — tap when ready';
        holdTimer.classList.add('visible');

        // Update hold timer
        updateHoldTimer();
      }

      function updateHoldTimer() {
        if (wimhofPhase !== 'hold' || !isRunning) return;

        const elapsed = Math.floor((Date.now() - holdStartTime) / 1000);
        const minutes = Math.floor(elapsed / 60);
        const seconds = elapsed % 60;
        holdTimer.textContent = minutes > 0
          ? `${minutes}:${seconds.toString().padStart(2, '0')}`
          : seconds.toString();

        requestAnimationFrame(updateHoldTimer);
      }

      function endWimHofHold() {
        holdTimer.classList.remove('visible');
        startWimHofRecovery();
      }

      function startWimHofRecovery() {
        wimhofPhase = 'recovery';
        phaseLabel.textContent = 'inhale and hold';
        phaseStartTime = Date.now();
        phaseDuration = currentPattern.recoveryHold * 1000;

        setTimeout(() => {
          if (!isRunning) return;

          roundIndex++;
          if (roundIndex >= currentPattern.rounds) {
            endSession();
          } else {
            startWimHofBreathing();
          }
        }, phaseDuration);
      }

      // ---------- Animation Loop ----------
      function animate() {
        if (!isRunning) return;

        // Clear canvas
        ctx.fillStyle = '#D1D1D1';
        ctx.fillRect(0, 0, width, height);

        if (!isPaused) {
          const now = Date.now();
          const elapsed = now - phaseStartTime;
          phaseProgress = Math.min(elapsed / phaseDuration, 1);

          // Check for phase completion (non-Wim Hof)
          if (currentPattern.type !== 'wimhof' && phaseProgress >= 1) {
            nextPhase();
          }

          // Get current phase name
          let currentPhaseName;
          if (currentPattern.type === 'wimhof') {
            currentPhaseName = wimhofPhase;
          } else {
            currentPhaseName = currentPattern.phases[phaseIndex].name;
          }

          // Render visual
          const visualFn = visuals[currentPattern.visual];
          if (visualFn) {
            visualFn(phaseProgress, currentPhaseName);
          }
        }

        animationId = requestAnimationFrame(animate);
      }

      function endSession() {
        isRunning = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        session.classList.remove('active');
        complete.classList.add('visible');
      }

      function exitSession() {
        isRunning = false;
        isPaused = false;
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        session.classList.remove('active');
        complete.classList.remove('visible');
        pausedOverlay.classList.remove('visible');
        holdTimer.classList.remove('visible');
        modeSelect.classList.remove('hidden');
      }

      function togglePause() {
        if (currentPattern.type === 'wimhof' && wimhofPhase === 'hold') {
          // During Wim Hof hold, tap ends the hold
          endWimHofHold();
          return;
        }

        isPaused = !isPaused;

        if (isPaused) {
          pausedOverlay.classList.add('visible');
          pauseBtn.textContent = 'Resume';
        } else {
          pausedOverlay.classList.remove('visible');
          pauseBtn.textContent = 'Pause';
          // Adjust phase start time to account for pause
          phaseStartTime = Date.now() - (phaseProgress * phaseDuration);
        }
      }

      // ---------- Event Listeners ----------
      // Mode selection
      document.querySelectorAll('.mode-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          if (e.target.classList.contains('info-btn')) return;
          const mode = btn.dataset.mode;
          startSession(mode);
        });
      });

      // Info buttons
      document.querySelectorAll('.info-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
          e.stopPropagation();
          const mode = btn.dataset.info;
          const info = infoContent[mode];
          infoTitle.textContent = info.title;
          infoText.textContent = info.text;
          infoPanel.classList.add('visible');
        });
      });

      closeInfo.addEventListener('click', () => {
        infoPanel.classList.remove('visible');
      });

      // Session controls
      pauseBtn.addEventListener('click', togglePause);
      exitBtn.addEventListener('click', exitSession);
      pausedOverlay.addEventListener('click', togglePause);

      // Complete screen
      repeatBtn.addEventListener('click', () => {
        complete.classList.remove('visible');
        startSession(currentMode);
      });

      newBtn.addEventListener('click', () => {
        complete.classList.remove('visible');
        modeSelect.classList.remove('hidden');
      });

      // Keyboard controls
      document.addEventListener('keydown', (e) => {
        if (e.code === 'Space' && session.classList.contains('active')) {
          e.preventDefault();
          togglePause();
        }
        if (e.code === 'Escape') {
          if (infoPanel.classList.contains('visible')) {
            infoPanel.classList.remove('visible');
          } else if (session.classList.contains('active')) {
            exitSession();
          }
        }
      });

      // Prevent screen sleep
      let wakeLock = null;
      async function requestWakeLock() {
        try {
          if ('wakeLock' in navigator) {
            wakeLock = await navigator.wakeLock.request('screen');
          }
        } catch (err) {
          // Wake lock not supported or denied
        }
      }

      // Window resize
      window.addEventListener('resize', resizeCanvas);

      // Initialize
      resizeCanvas();
      requestWakeLock();

    })();
  </script>
</body>
</html>
