<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="theme-color" content="#D1D1D1">
  <title>Somatic Interface — PUBLICWORKS</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #D1D1D1;
      --text: #0F0F0F;
      --text-dim: #6E6E6E;
      --accent: #0047FF;
      --alert: #FF4D00;
    }
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'IBM Plex Mono',monospace;background:var(--bg);color:var(--text);overflow:hidden}

    /* Start Screen - Minimal */
    #start{position:fixed;inset:0;background:var(--bg);display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:900;cursor:pointer}
    #start.hide{display:none}
    #start h1{font-family:'Space Grotesk',sans-serif;font-size:3rem;font-weight:700;letter-spacing:-0.04em;color:var(--text)}
    #start .sub{font-size:0.7rem;color:var(--text-dim);margin-top:0.5rem}
    #start .cta{font-size:0.8rem;color:var(--text);margin-top:3rem;padding:1rem 2.5rem;border:1px solid var(--text);font-weight:500;transition:all 0.15s}
    #start .cta:hover{background:var(--text);color:var(--bg)}

    /* Main */
    #back{position:fixed;top:1.5rem;left:1.5rem;font-size:0.7rem;color:var(--text);text-decoration:none;z-index:999;font-weight:500}
    #back:hover{color:var(--accent)}
    #glCanvas{position:fixed;top:0;left:0;width:100vw;height:100vh;z-index:1;background:#000}
    #canvas{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;z-index:2}

    /* TouchDesigner HUD - thin lines */
    .hud-panel{position:fixed;background:rgba(209,209,209,0.9);z-index:999;font-size:0.6rem;border:1px solid var(--text)}

    #info{bottom:1.5rem;right:1.5rem;padding:1rem 1.2rem;min-width:150px}
    #info .row{display:flex;justify-content:space-between;margin-bottom:0.4rem}
    #info .label{color:var(--text-dim);text-transform:uppercase;letter-spacing:0.05em}
    #info .val{font-weight:500}

    #left-guide{bottom:1.5rem;left:1.5rem;padding:0.8rem;border-color:var(--accent);max-width:160px}
    #left-guide h4{color:var(--accent);font-size:0.65rem;margin-bottom:0.6rem;text-transform:uppercase;letter-spacing:0.1em;font-weight:500}
    #left-guide .item{display:flex;justify-content:space-between;margin-bottom:0.3rem;font-size:0.55rem}
    #left-guide .gesture{color:var(--text)}
    #left-guide .effect{color:var(--text-dim)}

    #right-guide{top:1.5rem;right:1.5rem;padding:0.8rem;border-color:var(--alert);max-width:160px}
    #right-guide h4{color:var(--alert);font-size:0.65rem;margin-bottom:0.6rem;text-transform:uppercase;letter-spacing:0.1em;font-weight:500}
    #right-guide .item{display:flex;justify-content:space-between;margin-bottom:0.3rem;font-size:0.55rem}
    #right-guide .gesture{color:var(--text)}
    #right-guide .effect{color:var(--text-dim)}

    #status{top:1.5rem;left:50%;transform:translateX(-50%);padding:0.6rem 1.5rem;font-size:0.7rem;font-weight:500}
    #status.muted{border-color:var(--alert);color:var(--alert)}
  </style>
</head>
<body>
  <a href="../../" id="back" style="display:none">← PUBLICWORKS</a>

  <div id="start">
    <h1>Somatic Interface</h1>
    <p class="sub">005 — Body as instrument</p>
    <div class="cta">Enter</div>
  </div>

  <video id="video" autoplay playsinline style="display:none"></video>
  <canvas id="glCanvas"></canvas>
  <canvas id="canvas"></canvas>

  <!-- On-screen guides -->
  <div id="left-guide" class="hud-panel" style="display:none">
    <h4>Left Hand</h4>
    <div class="item"><span class="gesture">Palm</span><span class="effect">Bass Drop</span></div>
    <div class="item"><span class="gesture">Peace</span><span class="effect">Stab</span></div>
    <div class="item"><span class="gesture">Thumb</span><span class="effect">Kick</span></div>
    <div class="item"><span class="gesture">Point</span><span class="effect">Filter</span></div>
    <div class="item"><span class="gesture">Fist</span><span class="effect">Mute</span></div>
  </div>

  <div id="right-guide" class="hud-panel" style="display:none">
    <h4>Right Hand</h4>
    <div class="item"><span class="gesture">Up/Down</span><span class="effect">Chord</span></div>
    <div class="item"><span class="gesture">Left/Right</span><span class="effect">Speed</span></div>
    <div class="item"><span class="gesture">Rotate</span><span class="effect">Pattern</span></div>
    <div class="item"><span class="gesture">Present</span><span class="effect">Play</span></div>
  </div>

  <div id="info" class="hud-panel" style="display:none">
    <div class="row"><span class="label">Chord</span><span class="val" id="hChord">—</span></div>
    <div class="row"><span class="label">Pattern</span><span class="val" id="hPattern">—</span></div>
    <div class="row"><span class="label">BPM</span><span class="val" id="hBpm">—</span></div>
  </div>

  <div id="status" class="hud-panel" style="display:none">
    <span id="statusText">READY</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>

  <script>
    const video = document.getElementById('video');
    const glCanvas = document.getElementById('glCanvas');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startEl = document.getElementById('start');
    const statusEl = document.getElementById('status');

    // WebGL setup
    let gl, program, posBuffer, texBuffer;
    let videoTexture, faceMaskTexture;
    let uTime, uBass, uMid, uHigh, uFaceCenter, uFaceRadius, uFaceBoundsMin, uFaceBoundsMax;

    let W, H;
    let hands = [], handedness = [];
    let faceLandmarks = null;
    let frameCount = 0;
    let faceCenter = { x: 0.5, y: 0.5 };
    let faceRadius = 0.2;
    let faceBounds = { minX: 0.3, minY: 0.2, maxX: 0.7, maxY: 0.8 };

    // Audio analysis
    let analyser, freqData;
    let bassLevel = 0, midLevel = 0, highLevel = 0;
    let smoothBass = 0, smoothMid = 0, smoothHigh = 0;

    // Audio engine
    let ac, master, comp, delay, delayGain, reverb, revGain, globalFilter;
    let padVoices = [], lead, bass, stab;
    let arpTime = 0, arpIndex = 0;
    let patternIndex = 0;
    let lastLeftGesture = '';
    let isMuted = false;
    let bassDropActive = false;

    const ARP_PATTERNS = [
      { name: 'UP', fn: c => [...c] },
      { name: 'DOWN', fn: c => [...c].reverse() },
      { name: 'BOUNCE', fn: c => [...c, ...c.slice(1,-1).reverse()] },
      { name: 'SPREAD', fn: c => [c[0], c[3]+12, c[1], c[2]+12] },
    ];

    const CHORDS = {
      I:  [0, 4, 7, 11],
      vi: [9, 12, 16, 19],
      IV: [5, 9, 12, 16],
      V:  [7, 11, 14, 17],
    };
    const PROGRESSION = ['I', 'vi', 'IV', 'V'];
    const ROOT = 48;
    const mtof = m => 440 * Math.pow(2, (m - 69) / 12);

    function initAudio() {
      ac = new AudioContext();

      analyser = ac.createAnalyser();
      analyser.fftSize = 512;
      analyser.smoothingTimeConstant = 0.3;
      freqData = new Uint8Array(analyser.frequencyBinCount);

      comp = ac.createDynamicsCompressor();
      comp.threshold.value = -15;
      comp.knee.value = 20; // Softer knee
      comp.ratio.value = 4; // Gentler compression
      comp.attack.value = 0.01;
      comp.release.value = 0.4; // Slower release for sustained feel
      comp.connect(analyser);
      analyser.connect(ac.destination);

      master = ac.createGain();
      master.gain.value = 0.6;
      master.connect(comp);

      globalFilter = ac.createBiquadFilter();
      globalFilter.type = 'lowpass';
      globalFilter.frequency.value = 10000;
      globalFilter.Q.value = 0.5;
      globalFilter.connect(master);

      // Long spacey delay
      delay = ac.createDelay(2);
      delay.delayTime.value = 0.5; // Longer delay
      const fb = ac.createGain();
      fb.gain.value = 0.55; // More feedback for trailing echoes
      const dlp = ac.createBiquadFilter();
      dlp.type = 'lowpass';
      dlp.frequency.value = 2000; // Darker repeats
      delay.connect(dlp);
      dlp.connect(fb);
      fb.connect(delay);
      delayGain = ac.createGain();
      delayGain.gain.value = 0.4;
      delay.connect(delayGain);
      delayGain.connect(comp);

      // Long ethereal reverb - Interstellar style
      reverb = ac.createConvolver();
      const revLen = ac.sampleRate * 5; // 5 second tail
      const imp = ac.createBuffer(2, revLen, ac.sampleRate);
      for (let c = 0; c < 2; c++) {
        const d = imp.getChannelData(c);
        for (let i = 0; i < revLen; i++) {
          // Smooth decay with slight modulation for shimmer
          const decay = Math.pow(1 - i / revLen, 0.8);
          const shimmer = Math.sin(i * 0.0003) * 0.1 + 1;
          d[i] = (Math.random() * 2 - 1) * decay * shimmer;
        }
      }
      reverb.buffer = imp;
      revGain = ac.createGain();
      revGain.gain.value = 0.7; // More reverb for space
      reverb.connect(revGain);
      revGain.connect(comp);

      // PAD - Lush interstellar synth with 3 oscillators per voice
      for (let i = 0; i < 4; i++) {
        const o1 = ac.createOscillator();
        const o2 = ac.createOscillator();
        const o3 = ac.createOscillator();
        const f = ac.createBiquadFilter();
        const g = ac.createGain();

        // Rich detuned oscillators for that Interstellar organ feel
        o1.type = 'sine'; // Foundation
        o2.type = 'triangle'; // Warmth
        o3.type = 'sine'; // Shimmer octave up

        // Wide detuning for lush chorusing
        o1.detune.value = -8 + i * 2;
        o2.detune.value = 8 + i * 3;
        o3.detune.value = 1200 + 5 + i * 2; // Octave up with slight detune

        // Warm low-pass filter
        f.type = 'lowpass';
        f.frequency.value = 400; // Lower cutoff for warmth
        f.Q.value = 0.5;

        g.gain.value = 0;

        // Mix oscillators
        const o1g = ac.createGain(); o1g.gain.value = 0.5;
        const o2g = ac.createGain(); o2g.gain.value = 0.3;
        const o3g = ac.createGain(); o3g.gain.value = 0.15;

        o1.connect(o1g); o1g.connect(f);
        o2.connect(o2g); o2g.connect(f);
        o3.connect(o3g); o3g.connect(f);

        f.connect(g);
        g.connect(globalFilter);
        g.connect(reverb);
        o1.start(); o2.start(); o3.start();
        padVoices.push({ o1, o2, o3, f, g, o1g, o2g, o3g });
      }

      // LEAD - Ethereal plucky synth
      const lo1 = ac.createOscillator();
      const lo2 = ac.createOscillator();
      const lo3 = ac.createOscillator();
      const lf = ac.createBiquadFilter();
      const lg = ac.createGain();

      lo1.type = 'sine';
      lo2.type = 'triangle';
      lo3.type = 'sine';
      lo2.detune.value = 7;
      lo3.detune.value = 1200 + 3; // Subtle octave shimmer

      lf.type = 'lowpass';
      lf.frequency.value = 1800;
      lf.Q.value = 2;

      lg.gain.value = 0;

      const lo1g = ac.createGain(); lo1g.gain.value = 0.4;
      const lo2g = ac.createGain(); lo2g.gain.value = 0.35;
      const lo3g = ac.createGain(); lo3g.gain.value = 0.2;

      lo1.connect(lo1g); lo1g.connect(lf);
      lo2.connect(lo2g); lo2g.connect(lf);
      lo3.connect(lo3g); lo3g.connect(lf);

      lf.connect(lg);
      lg.connect(globalFilter);
      lg.connect(delay);
      lg.connect(reverb);
      lo1.start(); lo2.start(); lo3.start();
      lead = { o1: lo1, o2: lo2, o3: lo3, f: lf, g: lg };

      // BASS
      const bo1 = ac.createOscillator();
      const bo2 = ac.createOscillator();
      const bf = ac.createBiquadFilter();
      const bg = ac.createGain();
      bo1.type = 'sine';
      bo2.type = 'sawtooth';
      bo2.detune.value = -1200;
      bf.type = 'lowpass';
      bf.frequency.value = 200;
      bg.gain.value = 0;
      bo1.connect(bf); bo2.connect(bf);
      bf.connect(bg);
      bg.connect(master);
      bo1.start(); bo2.start();
      bass = { o1: bo1, o2: bo2, f: bf, g: bg };

      // STAB
      const so1 = ac.createOscillator();
      const so2 = ac.createOscillator();
      const sf = ac.createBiquadFilter();
      const sg = ac.createGain();
      so1.type = 'sawtooth';
      so2.type = 'square';
      so2.detune.value = 8;
      sf.type = 'lowpass';
      sf.frequency.value = 3000;
      sf.Q.value = 4;
      sg.gain.value = 0;
      so1.connect(sf); so2.connect(sf);
      sf.connect(sg);
      sg.connect(globalFilter);
      sg.connect(delay);
      sg.connect(reverb);
      so1.start(); so2.start();
      stab = { o1: so1, o2: so2, f: sf, g: sg };
    }

    function getAudioLevels() {
      if (!analyser) return;
      analyser.getByteFrequencyData(freqData);
      let b = 0, m = 0, h = 0;
      for (let i = 0; i < 8; i++) b += freqData[i];
      for (let i = 8; i < 40; i++) m += freqData[i];
      for (let i = 40; i < 100; i++) h += freqData[i];
      bassLevel = b / 8 / 255;
      midLevel = m / 32 / 255;
      highLevel = h / 60 / 255;
      // Smooth values
      smoothBass += (bassLevel - smoothBass) * 0.3;
      smoothMid += (midLevel - smoothMid) * 0.25;
      smoothHigh += (highLevel - smoothHigh) * 0.2;
    }

    // WebGL for video warping
    function initWebGL() {
      gl = glCanvas.getContext('webgl');
      if (!gl) { console.error('WebGL not supported'); return; }

      // Vertex shader
      const vsSource = `
        attribute vec2 aPos;
        attribute vec2 aTex;
        varying vec2 vTex;
        void main() {
          gl_Position = vec4(aPos, 0.0, 1.0);
          vTex = aTex;
        }
      `;

      // Fragment shader with audio-reactive blur effect on face
      const fsSource = `
        precision mediump float;
        varying vec2 vTex;
        uniform sampler2D uVideo;
        uniform float uTime;
        uniform float uBass;
        uniform float uMid;
        uniform float uHigh;
        uniform vec2 uFaceCenter;
        uniform float uFaceRadius;
        uniform vec2 uFaceBoundsMin;
        uniform vec2 uFaceBoundsMax;

        void main() {
          // Mirror UV for display
          vec2 uv = vec2(1.0 - vTex.x, vTex.y);

          // Check bounds in mirrored/screen space
          float edgeSoftness = 0.03;
          float mirroredMinX = 1.0 - uFaceBoundsMax.x;
          float mirroredMaxX = 1.0 - uFaceBoundsMin.x;

          float inBoxX = smoothstep(mirroredMinX - edgeSoftness, mirroredMinX + edgeSoftness, uv.x)
                       * smoothstep(mirroredMaxX + edgeSoftness, mirroredMaxX - edgeSoftness, uv.x);
          float inBoxY = smoothstep(uFaceBoundsMin.y - edgeSoftness, uFaceBoundsMin.y + edgeSoftness, uv.y)
                       * smoothstep(uFaceBoundsMax.y + edgeSoftness, uFaceBoundsMax.y - edgeSoftness, uv.y);
          float faceMask = inBoxX * inBoxY;

          // Base blur amount reactive to audio
          float blurAmount = (0.008 + uBass * 0.015 + uMid * 0.008) * faceMask;

          // Sample multiple points for blur effect
          vec4 color = vec4(0.0);
          float total = 0.0;

          // 9-tap blur kernel
          for (float x = -1.0; x <= 1.0; x += 1.0) {
            for (float y = -1.0; y <= 1.0; y += 1.0) {
              float weight = 1.0 - length(vec2(x, y)) * 0.3;
              vec2 offset = vec2(x, y) * blurAmount;
              color += texture2D(uVideo, vTex + offset) * weight;
              total += weight;
            }
          }
          color /= total;

          // Get sharp original
          vec4 sharp = texture2D(uVideo, vTex);

          // Mix blur and sharp based on face mask
          vec4 final = mix(sharp, color, faceMask * 0.85);

          // Subtle chromatic aberration on high audio
          float chromaAmt = uBass * 0.006 * faceMask;
          final.r = mix(sharp.r, texture2D(uVideo, vTex + vec2(chromaAmt, 0.0)).r, faceMask * 0.5);
          final.b = mix(sharp.b, texture2D(uVideo, vTex - vec2(chromaAmt, 0.0)).b, faceMask * 0.5);

          gl_FragColor = final;
        }
      `;

      function compileShader(src, type) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
          console.error(gl.getShaderInfoLog(s));
          return null;
        }
        return s;
      }

      const vs = compileShader(vsSource, gl.VERTEX_SHADER);
      const fs = compileShader(fsSource, gl.FRAGMENT_SHADER);

      program = gl.createProgram();
      gl.attachShader(program, vs);
      gl.attachShader(program, fs);
      gl.linkProgram(program);
      gl.useProgram(program);

      // Fullscreen quad
      posBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        -1, -1,  1, -1,  -1, 1,
        -1, 1,   1, -1,   1, 1
      ]), gl.STATIC_DRAW);

      const aPos = gl.getAttribLocation(program, 'aPos');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

      texBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, texBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
        0, 1,  1, 1,  0, 0,
        0, 0,  1, 1,  1, 0
      ]), gl.STATIC_DRAW);

      const aTex = gl.getAttribLocation(program, 'aTex');
      gl.enableVertexAttribArray(aTex);
      gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 0, 0);

      // Video texture
      videoTexture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, videoTexture);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

      // Get uniform locations
      uTime = gl.getUniformLocation(program, 'uTime');
      uBass = gl.getUniformLocation(program, 'uBass');
      uMid = gl.getUniformLocation(program, 'uMid');
      uHigh = gl.getUniformLocation(program, 'uHigh');
      uFaceCenter = gl.getUniformLocation(program, 'uFaceCenter');
      uFaceRadius = gl.getUniformLocation(program, 'uFaceRadius');
      uFaceBoundsMin = gl.getUniformLocation(program, 'uFaceBoundsMin');
      uFaceBoundsMax = gl.getUniformLocation(program, 'uFaceBoundsMax');
    }

    function renderVideo() {
      if (!gl || !video.videoWidth) return;

      gl.viewport(0, 0, glCanvas.width, glCanvas.height);

      // Update video texture
      gl.bindTexture(gl.TEXTURE_2D, videoTexture);
      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, video);

      // Update uniforms
      gl.uniform1f(uTime, frameCount * 0.016);
      gl.uniform1f(uBass, smoothBass);
      gl.uniform1f(uMid, smoothMid);
      gl.uniform1f(uHigh, smoothHigh);
      gl.uniform2f(uFaceCenter, faceCenter.x, faceCenter.y);
      gl.uniform1f(uFaceRadius, faceRadius);
      gl.uniform2f(uFaceBoundsMin, faceBounds.minX, faceBounds.minY);
      gl.uniform2f(uFaceBoundsMax, faceBounds.maxX, faceBounds.maxY);

      // Draw
      gl.drawArrays(gl.TRIANGLES, 0, 6);
    }

    function triggerKick() {
      if (!ac || isMuted) return;
      const t = ac.currentTime;
      const ko = ac.createOscillator();
      const ko2 = ac.createOscillator();
      const kg = ac.createGain();
      ko.type = 'sine';
      ko2.type = 'triangle';
      ko.frequency.setValueAtTime(150, t);
      ko.frequency.exponentialRampToValueAtTime(30, t + 0.12);
      ko2.frequency.setValueAtTime(80, t);
      ko2.frequency.exponentialRampToValueAtTime(20, t + 0.08);
      kg.gain.setValueAtTime(0.55, t);
      kg.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
      ko.connect(kg); ko2.connect(kg);
      kg.connect(master);
      ko.start(t); ko2.start(t);
      ko.stop(t + 0.3); ko2.stop(t + 0.3);
    }

    function triggerStab(chord) {
      if (!ac || isMuted) return;
      const t = ac.currentTime;
      // Ethereal chord stab with soft attack
      chord.forEach((n, i) => {
        const freq = mtof(ROOT + 12 + n);
        setTimeout(() => {
          stab.o1.frequency.setTargetAtTime(freq, ac.currentTime, 0.02);
          stab.o2.frequency.setTargetAtTime(freq, ac.currentTime, 0.025);
          stab.g.gain.cancelScheduledValues(ac.currentTime);
          stab.g.gain.setTargetAtTime(0.18, ac.currentTime, 0.05); // Soft attack
          stab.g.gain.setTargetAtTime(0.001, ac.currentTime + 0.15, 0.4); // Long tail
        }, i * 40); // Slightly arpeggiated
      });
      delayGain.gain.setTargetAtTime(0.6, t, 0.05);
      setTimeout(() => delayGain.gain.setTargetAtTime(0.4, ac.currentTime, 0.3), 600);
    }

    function triggerBassDrop(chord) {
      if (!ac || bassDropActive || isMuted) return;
      bassDropActive = true;
      const t = ac.currentTime;
      const note = chord[0] - 12;

      // Deep space bass with slower sweep
      bass.o1.frequency.setTargetAtTime(mtof(ROOT + note), t, 0.01);
      bass.o2.frequency.setTargetAtTime(mtof(ROOT + note), t, 0.01);
      bass.f.frequency.setValueAtTime(800, t);
      bass.f.frequency.exponentialRampToValueAtTime(40, t + 0.5); // Slower sweep
      bass.g.gain.setValueAtTime(0.4, t);
      bass.g.gain.setTargetAtTime(0.12, t + 0.1, 0.4); // Prolonged sustain

      globalFilter.frequency.setValueAtTime(200, t);
      globalFilter.frequency.exponentialRampToValueAtTime(10000, t + 0.6);

      setTimeout(() => { bassDropActive = false; }, 800);
    }

    function detectGesture(hand) {
      if (!hand) return 'none';
      const ext = (tip, pip) => hand[tip].y < hand[pip].y;
      const thumb = ext(4, 3);
      const index = ext(8, 6);
      const middle = ext(12, 10);
      const ring = ext(16, 14);
      const pinky = ext(20, 18);

      if (!thumb && !index && !middle && !ring && !pinky) return 'fist';
      if (thumb && !index && !middle && !ring && !pinky) return 'thumb';
      if (index && !middle && !ring && !pinky) return 'point';
      if (index && middle && !ring && !pinky) return 'peace';
      if (thumb && index && middle && ring && pinky) return 'palm';
      return 'open';
    }

    function getHand(label) {
      for (let i = 0; i < hands.length; i++) {
        if (handedness[i] === label) return hands[i];
      }
      return null;
    }

    function updateAudio() {
      if (!ac) return;
      const t = ac.currentTime;
      const lHand = getHand('Left');
      const rHand = getHand('Right');

      getAudioLevels();

      // LEFT HAND - Effects
      const leftGesture = detectGesture(lHand);

      if (leftGesture === 'fist') {
        isMuted = true;
        globalFilter.frequency.setTargetAtTime(150, t, 0.03);
        master.gain.setTargetAtTime(0.08, t, 0.08);
        statusEl.classList.add('muted');
        document.getElementById('statusText').textContent = 'MUTED';
      } else {
        isMuted = false;
        master.gain.setTargetAtTime(0.6, t, 0.1);
        statusEl.classList.remove('muted');
      }

      if (leftGesture === 'palm' && lastLeftGesture !== 'palm') {
        triggerBassDrop(CHORDS[PROGRESSION[0]]);
        document.getElementById('statusText').textContent = 'BASS DROP';
      }

      if (leftGesture === 'peace' && lastLeftGesture !== 'peace') {
        const chordIdx = rHand && rHand[9] ? Math.floor(rHand[9].y * 4) : 0;
        triggerStab(CHORDS[PROGRESSION[Math.max(0, Math.min(3, chordIdx))]]);
        document.getElementById('statusText').textContent = 'STAB';
      }

      if (leftGesture === 'thumb' && lastLeftGesture !== 'thumb') {
        triggerKick();
        document.getElementById('statusText').textContent = 'KICK';
      }

      if (leftGesture === 'point' && lHand) {
        const y = lHand[8] ? lHand[8].y : 0.5;
        const freq = 600 + (1 - y) * 9000;
        globalFilter.frequency.setTargetAtTime(freq, t, 0.02);
        document.getElementById('statusText').textContent = 'FILTER';
      } else if (!isMuted && leftGesture !== 'palm') {
        globalFilter.frequency.setTargetAtTime(10000, t, 0.12);
      }

      if (leftGesture === 'open' || leftGesture === 'none') {
        if (!isMuted) document.getElementById('statusText').textContent = rHand ? 'PLAYING' : 'READY';
      }

      lastLeftGesture = leftGesture;

      // RIGHT HAND - Harmony
      if (rHand) {
        const ry = rHand[9] ? rHand[9].y : 0.5;
        const rx = rHand[9] ? rHand[9].x : 0.5;

        let chordIdx = Math.floor(ry * 4);
        chordIdx = Math.max(0, Math.min(3, chordIdx));
        const chordName = PROGRESSION[chordIdx];
        const chord = CHORDS[chordName];
        document.getElementById('hChord').textContent = chordName;

        const wrist = rHand[0];
        const middle = rHand[9];
        const angle = Math.atan2(middle.x - wrist.x, middle.y - wrist.y);
        const pIdx = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * ARP_PATTERNS.length);
        patternIndex = Math.abs(pIdx) % ARP_PATTERNS.length;
        document.getElementById('hPattern').textContent = ARP_PATTERNS[patternIndex].name;

        if (!isMuted) {
          // Interstellar-style slow filter movement
          const padFilter = 300 + (1 - ry) * 800; // Lower, warmer
          chord.forEach((note, i) => {
            if (!padVoices[i]) return;
            const freq = mtof(ROOT + note);
            // Very slow glide for that organ-like sustained feel
            padVoices[i].o1.frequency.setTargetAtTime(freq, t, 0.8);
            padVoices[i].o2.frequency.setTargetAtTime(freq, t, 0.9);
            if (padVoices[i].o3) padVoices[i].o3.frequency.setTargetAtTime(freq * 2, t, 0.85);
            padVoices[i].f.frequency.setTargetAtTime(padFilter, t, 0.3);
            // Slow swell - prolonged attack
            padVoices[i].g.gain.setTargetAtTime(0.12, t, 1.2);
          });

          const bassNote = chord[0] - 12;
          bass.o1.frequency.setTargetAtTime(mtof(ROOT + bassNote), t, 0.5);
          bass.o2.frequency.setTargetAtTime(mtof(ROOT + bassNote), t, 0.5);
          if (!bassDropActive) bass.g.gain.setTargetAtTime(0.1, t, 0.6);
        }

        // Slower BPM range for more meditative feel
        const bpm = 50 + rx * 100; // 50-150 BPM range
        const stepTime = 60 / bpm / 2;
        document.getElementById('hBpm').textContent = Math.round(bpm);

        const brightness = 800 + (1 - ry) * 2000; // Softer brightness range

        if (!isMuted && t - arpTime > stepTime) {
          arpTime = t;
          const pattern = ARP_PATTERNS[patternIndex].fn(chord);
          const note = pattern[arpIndex % pattern.length];
          const freq = mtof(ROOT + 12 + note);

          // Soft glide between notes
          lead.o1.frequency.setTargetAtTime(freq, t, 0.05);
          lead.o2.frequency.setTargetAtTime(freq, t, 0.06);
          if (lead.o3) lead.o3.frequency.setTargetAtTime(freq * 2, t, 0.055);
          lead.f.frequency.setTargetAtTime(brightness, t, 0.1);

          // Soft attack, long release - ethereal plucks
          lead.g.gain.cancelScheduledValues(t);
          lead.g.gain.setTargetAtTime(0.14, t, 0.08); // Soft attack
          lead.g.gain.setTargetAtTime(0.001, t + stepTime * 0.3, stepTime * 0.8); // Long tail

          arpIndex++;
        }
      } else {
        document.getElementById('hChord').textContent = '—';
        document.getElementById('hPattern').textContent = '—';
        document.getElementById('hBpm').textContent = '—';
        // Very slow fade out for sustained feel
        padVoices.forEach(v => v.g.gain.setTargetAtTime(0, t, 1.5));
        bass.g.gain.setTargetAtTime(0, t, 1.2);
        lead.g.gain.setTargetAtTime(0, t, 0.8);
      }
    }

    // TRACKING
    let handsModel, faceModel;

    async function initTracking() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 1280, height: 720, facingMode: 'user' }
      });
      video.srcObject = stream;
      await video.play();

      handsModel = new Hands({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}`
      });
      handsModel.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.5
      });
      handsModel.onResults(r => {
        hands = r.multiHandLandmarks || [];
        handedness = (r.multiHandedness || []).map(h => h.label);
      });
      await handsModel.initialize();

      faceModel = new FaceMesh({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${f}`
      });
      faceModel.setOptions({
        maxNumFaces: 1,
        refineLandmarks: true,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      faceModel.onResults(r => {
        faceLandmarks = r.multiFaceLandmarks?.[0] || null;
      });
      await faceModel.initialize();

      let frameNum = 0;
      async function process() {
        frameNum++;
        await handsModel.send({ image: video });
        if (frameNum % 2 === 0) {
          await faceModel.send({ image: video });
        }
        requestAnimationFrame(process);
      }
      process();
    }

    // DRAWING - TouchDesigner thin lines style
    function draw() {
      if (!W || !H) return;
      ctx.clearRect(0, 0, W, H);
      frameCount++;

      // Render video with WebGL warping
      renderVideo();

      // FACE - Update face center for WebGL shader + thin overlay
      if (faceLandmarks) {
        const pts = faceLandmarks;

        // Calculate face center (normalized 0-1) for shader
        let cx = 0, cy = 0;
        pts.forEach(p => { cx += p.x; cy += p.y; });
        cx = cx / pts.length;
        cy = cy / pts.length;

        // Calculate face radius
        let maxDist = 0;
        pts.forEach(p => {
          const d = Math.sqrt((p.x - cx) ** 2 + (p.y - cy) ** 2);
          maxDist = Math.max(maxDist, d);
        });
        faceRadius = maxDist * 1.2;

        // Calculate face bounding box (normalized, NO mirroring - shader handles it)
        let fMinX = Infinity, fMinY = Infinity, fMaxX = -Infinity, fMaxY = -Infinity;
        pts.forEach(p => {
          fMinX = Math.min(fMinX, p.x);
          fMinY = Math.min(fMinY, p.y);
          fMaxX = Math.max(fMaxX, p.x);
          fMaxY = Math.max(fMaxY, p.y);
        });
        const pad = 0.03;
        faceBounds = {
          minX: fMinX - pad,
          minY: fMinY - pad,
          maxX: fMaxX + pad,
          maxY: fMaxY + pad
        };
        // Face center also not mirrored
        faceCenter = { x: cx, y: cy };

        // Convert to screen coords for overlay (mirrored)
        const scx = (1 - cx) * W;
        const scy = cy * H;

        // Thin mesh connections - TouchDesigner style
        const faceConnections = [
          [10,338,297,332,284,251,389,356,454,323,361,288,397,365,379,378,400,377,152,148,176,149,150,136,172,58,132,93,234,127,162,21,54,103,67,109,10],
          [33,246,161,160,159,158,157,173,133,155,154,153,145,144,163,7,33],
          [263,466,388,387,386,385,384,398,362,382,381,380,374,373,390,249,263],
          [168,6,197,195,5,4,1,19,94,2,164,0,11,12,13,14,15,16,17,18,200,199,175,152],
          [61,146,91,181,84,17,314,405,321,375,291,409,270,269,267,0,37,39,40,185,61],
          [78,95,88,178,87,14,317,402,318,324,308,415,310,311,312,13,82,81,80,191,78],
        ];

        // Convert points to screen coords (mirrored)
        const screenPts = pts.map(p => ({
          x: (1 - p.x) * W,
          y: p.y * H
        }));

        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';

        // Draw thin lines - TouchDesigner aesthetic
        faceConnections.forEach((conn) => {
          ctx.strokeStyle = `rgba(0, 71, 255, ${0.4 + smoothBass * 0.3})`;
          ctx.lineWidth = 1;

          ctx.beginPath();
          conn.forEach((idx, i) => {
            if (idx >= screenPts.length) return;
            const p = screenPts[idx];
            if (i === 0) ctx.moveTo(p.x, p.y);
            else ctx.lineTo(p.x, p.y);
          });
          ctx.stroke();
        });

        // Draw small points
        ctx.fillStyle = `rgba(0, 71, 255, ${0.5 + smoothMid * 0.3})`;
        screenPts.forEach((p, i) => {
          if (i % 5 === 0) {
            const size = 2 + smoothBass * 2;
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            ctx.fill();
          }
        });

        // Thin bounding box
        let fx1 = Infinity, fy1 = Infinity, fx2 = -Infinity, fy2 = -Infinity;
        screenPts.forEach(p => {
          fx1 = Math.min(fx1, p.x); fy1 = Math.min(fy1, p.y);
          fx2 = Math.max(fx2, p.x); fy2 = Math.max(fy2, p.y);
        });

        ctx.strokeStyle = `rgba(0, 71, 255, ${0.5 + smoothBass * 0.3})`;
        ctx.lineWidth = 1;
        ctx.strokeRect(fx1 - 15, fy1 - 15, fx2 - fx1 + 30, fy2 - fy1 + 30);

        // Corner brackets
        const cs = 12 + smoothBass * 8;
        ctx.lineWidth = 1;
        [[fx1-15, fy1-15, 1, 1], [fx2+15, fy1-15, -1, 1],
         [fx1-15, fy2+15, 1, -1], [fx2+15, fy2+15, -1, -1]].forEach(([x, y, dx, dy]) => {
          ctx.beginPath();
          ctx.moveTo(x, y + dy * cs);
          ctx.lineTo(x, y);
          ctx.lineTo(x + dx * cs, y);
          ctx.stroke();
        });

        // Data label
        ctx.fillStyle = 'rgba(0, 71, 255, 0.7)';
        ctx.font = '9px IBM Plex Mono';
        ctx.fillText(`FACE [${pts.length}pts]`, fx1 - 15, fy1 - 22);

        // Concentric circles around face center
        ctx.strokeStyle = `rgba(0, 71, 255, 0.25)`;
        ctx.lineWidth = 1;
        for (let r = 30; r < 150; r += 25) {
          const radius = r + smoothBass * 20;
          ctx.beginPath();
          ctx.arc(scx, scy, radius, 0, Math.PI * 2);
          ctx.stroke();
        }

        // Radial lines from face center
        ctx.strokeStyle = `rgba(0, 71, 255, 0.2)`;
        for (let a = 0; a < Math.PI * 2; a += Math.PI / 8) {
          ctx.beginPath();
          ctx.moveTo(scx + Math.cos(a) * 40, scy + Math.sin(a) * 40);
          ctx.lineTo(scx + Math.cos(a) * 140, scy + Math.sin(a) * 140);
          ctx.stroke();
        }

        // Data readouts near face
        ctx.fillStyle = 'rgba(0, 71, 255, 0.5)';
        ctx.font = '8px IBM Plex Mono';
        ctx.fillText(`X:${cx.toFixed(3)}`, fx2 + 20, fy1);
        ctx.fillText(`Y:${cy.toFixed(3)}`, fx2 + 20, fy1 + 12);
        ctx.fillText(`0x${Math.floor(cx * 65535).toString(16).toUpperCase()}`, fx2 + 20, fy1 + 24);
      }

      // HANDS - Thin lines style
      hands.forEach((hand, hi) => {
        const isRight = handedness[hi] === 'Right';
        const col = isRight ? '255, 77, 0' : '0, 71, 255';

        // Convert to screen coords (mirrored)
        const screenHand = hand.map(p => ({
          x: (1 - p.x) * W,
          y: p.y * H
        }));

        const bones = [
          [0,1],[1,2],[2,3],[3,4],
          [0,5],[5,6],[6,7],[7,8],
          [5,9],[9,10],[10,11],[11,12],
          [9,13],[13,14],[14,15],[15,16],
          [13,17],[17,18],[18,19],[19,20],
          [0,17]
        ];

        // Thin skeleton
        ctx.strokeStyle = `rgba(${col}, 0.7)`;
        ctx.lineWidth = 1;
        ctx.lineCap = 'round';
        ctx.beginPath();
        bones.forEach(([a, b]) => {
          ctx.moveTo(screenHand[a].x, screenHand[a].y);
          ctx.lineTo(screenHand[b].x, screenHand[b].y);
        });
        ctx.stroke();

        // Small circles on tips
        [4, 8, 12, 16, 20].forEach(i => {
          ctx.fillStyle = `rgba(${col}, 0.8)`;
          ctx.beginPath();
          ctx.arc(screenHand[i].x, screenHand[i].y, 4, 0, Math.PI * 2);
          ctx.fill();
        });

        // Tiny dots on joints
        screenHand.forEach((pt, i) => {
          if ([4, 8, 12, 16, 20].includes(i)) return;
          ctx.fillStyle = `rgba(${col}, 0.4)`;
          ctx.beginPath();
          ctx.arc(pt.x, pt.y, 2, 0, Math.PI * 2);
          ctx.fill();
        });

        // Thin bounding box
        let x1 = Infinity, y1 = Infinity, x2 = -Infinity, y2 = -Infinity;
        screenHand.forEach(p => {
          x1 = Math.min(x1, p.x); y1 = Math.min(y1, p.y);
          x2 = Math.max(x2, p.x); y2 = Math.max(y2, p.y);
        });

        ctx.strokeStyle = `rgba(${col}, 0.6)`;
        ctx.lineWidth = 1;
        ctx.strokeRect(x1 - 12, y1 - 12, x2 - x1 + 24, y2 - y1 + 24);

        // Corner brackets
        const cs = 8;
        [[x1-12, y1-12, 1, 1], [x2+12, y1-12, -1, 1],
         [x1-12, y2+12, 1, -1], [x2+12, y2+12, -1, -1]].forEach(([x, y, dx, dy]) => {
          ctx.beginPath();
          ctx.moveTo(x, y + dy * cs);
          ctx.lineTo(x, y);
          ctx.lineTo(x + dx * cs, y);
          ctx.stroke();
        });

        ctx.fillStyle = `rgba(${col}, 0.8)`;
        ctx.font = '9px IBM Plex Mono';
        ctx.fillText(isRight ? 'R_HAND' : 'L_HAND', x1 - 12, y1 - 18);

        // Connection lines from fingertips outward
        ctx.strokeStyle = `rgba(${col}, 0.3)`;
        ctx.lineWidth = 1;
        [4, 8, 12, 16, 20].forEach((i, idx) => {
          const tip = screenHand[i];
          const angle = -Math.PI/2 + (idx - 2) * 0.3;
          ctx.beginPath();
          ctx.moveTo(tip.x, tip.y);
          ctx.lineTo(tip.x + Math.cos(angle) * 40, tip.y + Math.sin(angle) * 40);
          ctx.stroke();
          // Small data label
          ctx.fillStyle = `rgba(${col}, 0.4)`;
          ctx.font = '7px IBM Plex Mono';
          ctx.fillText(`${i}`, tip.x + Math.cos(angle) * 45, tip.y + Math.sin(angle) * 45);
        });

        // Circle around palm
        const palmX = screenHand[9].x;
        const palmY = screenHand[9].y;
        ctx.strokeStyle = `rgba(${col}, 0.25)`;
        ctx.beginPath();
        ctx.arc(palmX, palmY, 35 + smoothBass * 15, 0, Math.PI * 2);
        ctx.stroke();

        // Hex address label
        ctx.fillStyle = `rgba(${col}, 0.5)`;
        ctx.font = '8px IBM Plex Mono';
        const hexAddr = `0x${Math.floor(hand[9].x * 65535).toString(16).toUpperCase()}`;
        ctx.fillText(hexAddr, x2 + 15, (y1 + y2) / 2);
      });
    }

    function loop() {
      draw();
      updateAudio();
      requestAnimationFrame(loop);
    }

    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;
      glCanvas.width = W;
      glCanvas.height = H;
      if (gl) {
        gl.viewport(0, 0, W, H);
      }
    }

    async function begin() {
      startEl.classList.add('hide');
      document.getElementById('back').style.display = 'block';
      resize();
      initWebGL();
      await initTracking();
      initAudio();
      document.getElementById('info').style.display = 'block';
      document.getElementById('left-guide').style.display = 'block';
      document.getElementById('right-guide').style.display = 'block';
      document.getElementById('status').style.display = 'block';
      loop();
    }

    startEl.addEventListener('click', begin);
    window.addEventListener('resize', resize);
  </script>
</body>
</html>
