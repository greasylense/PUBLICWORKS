<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Somatic Interface — PUBLICWORKS</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'IBM Plex Mono',monospace;background:#000;color:#0F0F0F;overflow:hidden}
    #back{position:fixed;top:1.5rem;left:1.5rem;font-size:0.7rem;color:rgba(255,255,255,0.5);text-decoration:none;z-index:999;transition:color 0.15s}
    #back:hover{color:#0047FF}
    #start{position:fixed;inset:0;background:#D1D1D1;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:900;cursor:pointer;transition:opacity 0.5s}
    #start.hide{display:none}
    #start h1{font-size:2.2rem;font-weight:400;letter-spacing:-0.02em;color:#0F0F0F}
    #start .sub{font-size:0.7rem;color:#6E6E6E;margin-bottom:0.5rem}
    #start .concept{max-width:420px;text-align:center;margin:1.5rem 1rem;font-size:0.85rem;color:#0F0F0F;line-height:1.7}
    #start .desc{max-width:380px;text-align:center;margin:0.5rem 1rem 1.5rem;font-size:0.7rem;color:#6E6E6E;line-height:1.6}
    #start .cta{font-size:0.6rem;color:#0047FF;text-transform:uppercase;letter-spacing:0.15em}
    #start .req{position:absolute;bottom:2rem;font-size:0.55rem;color:#999;text-transform:uppercase;letter-spacing:0.1em}
    #video{position:fixed;top:0;left:0;width:100vw;height:100vh;object-fit:cover;transform:scaleX(-1);z-index:1;background:#000}
    #canvas{position:fixed;top:0;left:0;width:100vw;height:100vh;pointer-events:none;transform:scaleX(-1);z-index:2;background:transparent}
    #hud{position:fixed;bottom:1.5rem;right:1.5rem;font-size:0.55rem;color:#fff;background:rgba(0,0,0,0.7);padding:0.6rem 0.8rem;border:1px solid rgba(255,255,255,0.2);z-index:999;min-width:140px}
    #hud div{margin-bottom:0.2rem}
    #hud .label{color:rgba(255,255,255,0.5)}
    #gesture{position:fixed;top:1.5rem;right:1.5rem;font-size:0.7rem;color:#0047FF;background:rgba(0,0,0,0.7);padding:0.5rem 0.7rem;border:1px solid #0047FF;z-index:999}
    #guide{position:fixed;bottom:1.5rem;left:1.5rem;font-size:0.5rem;color:rgba(255,255,255,0.7);background:rgba(0,0,0,0.7);padding:0.6rem 0.8rem;border:1px solid rgba(255,255,255,0.15);z-index:999;line-height:1.8;max-width:200px}
    #guide .title{color:#0047FF;font-size:0.55rem;margin-bottom:0.4rem;text-transform:uppercase;letter-spacing:0.1em}
    #guide .row{display:flex;justify-content:space-between;gap:1rem}
    #guide .key{color:rgba(255,255,255,0.4)}
    #arp-mode{position:fixed;top:1.5rem;left:50%;transform:translateX(-50%);font-size:0.55rem;color:#FF4D00;background:rgba(0,0,0,0.7);padding:0.4rem 0.8rem;border:1px solid #FF4D00;z-index:999;text-transform:uppercase;letter-spacing:0.1em}
  </style>
</head>
<body>
  <a href="../../" id="back">← PUBLICWORKS</a>
  <div id="start">
    <div class="sub">005</div>
    <h1>Somatic Interface</h1>
    <p class="concept">An exploration of embodied interaction — where your body becomes the instrument. This experiment bridges the gap between physical gesture and digital sound, asking: what happens when technology learns to listen to our bodies?</p>
    <p class="desc">Use your hands as controllers. Right hand shapes harmony and triggers sounds through gestures. Left hand plays an evolving arpeggiator. Your facial expressions add nuance and feeling to every note.</p>
    <p class="cta">Click to begin</p>
    <p class="req">Requires webcam + audio</p>
  </div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <div id="hud" style="display:none">
    <div><span class="label">CHORD</span> <span id="hC">—</span></div>
    <div><span class="label">PATTERN</span> <span id="hP">—</span></div>
    <div><span class="label">BPM</span> <span id="hB">—</span></div>
    <div><span class="label">EXPRESSION</span> <span id="hE">—</span></div>
  </div>

  <div id="gesture" style="display:none"><span id="gIcon">●</span> <span id="gName">READY</span></div>

  <div id="arp-mode" style="display:none">ARP: <span id="arpName">UP</span></div>

  <div id="guide" style="display:none">
    <div class="title">Controls</div>
    <div class="row"><span class="key">R Hand Up/Down</span><span>Chord</span></div>
    <div class="row"><span class="key">L Hand X</span><span>Speed</span></div>
    <div class="row"><span class="key">L Hand Y</span><span>Brightness</span></div>
    <div class="row"><span class="key">Palm</span><span>Open Filter</span></div>
    <div class="row"><span class="key">Fist</span><span>Mute</span></div>
    <div class="row"><span class="key">Peace</span><span>Stab + Delay</span></div>
    <div class="row"><span class="key">Thumbs Up</span><span>Kick</span></div>
    <div class="row"><span class="key">Point</span><span>Bright Lead</span></div>
    <div class="row"><span class="key">Face</span><span>Expression</span></div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/face_mesh.js"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startEl = document.getElementById('start');

    let W, H;
    let hands = [], handedness = [];
    let faceLandmarks = null;
    let frameCount = 0;
    const traces = [];
    const particles = [];

    // ============ AUDIO ENGINE ============
    let ac, master, comp, delay, delayGain, reverb, revGain;
    let padVoices = [], lead, bass, stab;
    let arpTime = 0, arpIndex = 0;
    let lastGesture = '', currentChord = 'I';
    let expressionMod = 0.5;

    // Arpeggiator patterns
    const ARP_PATTERNS = {
      up: (chord) => [...chord],
      down: (chord) => [...chord].reverse(),
      updown: (chord) => [...chord, ...chord.slice(1, -1).reverse()],
      random: (chord) => chord.map((_, i, arr) => arr[Math.floor(Math.random() * arr.length)]),
      octaves: (chord) => [chord[0], chord[0] + 12, chord[2], chord[2] + 12],
      fifths: (chord) => [chord[0], chord[0] + 7, chord[0] + 12, chord[0] + 7],
      spread: (chord) => [chord[0], chord[2] + 12, chord[1], chord[3] + 12]
    };
    const ARP_NAMES = Object.keys(ARP_PATTERNS);
    let currentArpPattern = 'up';
    let arpSwitchTime = 0;

    const CHORDS = {
      I:   [0, 4, 7, 11],
      ii:  [2, 5, 9, 12],
      IV:  [5, 9, 12, 16],
      V:   [7, 11, 14, 17],
      vi:  [9, 12, 16, 19]
    };
    const PROGRESSION = ['I', 'vi', 'IV', 'V'];
    const ROOT = 48;
    const mtof = m => 440 * Math.pow(2, (m - 69) / 12);

    function initAudio() {
      ac = new AudioContext();

      comp = ac.createDynamicsCompressor();
      comp.threshold.value = -18;
      comp.knee.value = 12;
      comp.ratio.value = 6;
      comp.attack.value = 0.01;
      comp.release.value = 0.25;
      comp.connect(ac.destination);

      master = ac.createGain();
      master.gain.value = 0.5;
      master.connect(comp);

      delay = ac.createDelay(1);
      delay.delayTime.value = 0.375;
      const fb = ac.createGain();
      fb.gain.value = 0.35;
      const lpf = ac.createBiquadFilter();
      lpf.type = 'lowpass';
      lpf.frequency.value = 2200;
      delay.connect(lpf);
      lpf.connect(fb);
      fb.connect(delay);
      delayGain = ac.createGain();
      delayGain.gain.value = 0.25;
      delay.connect(delayGain);
      delayGain.connect(comp);

      reverb = ac.createConvolver();
      const revLen = ac.sampleRate * 2.8;
      const imp = ac.createBuffer(2, revLen, ac.sampleRate);
      for (let c = 0; c < 2; c++) {
        const d = imp.getChannelData(c);
        for (let i = 0; i < revLen; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / revLen, 1.8);
        }
      }
      reverb.buffer = imp;
      revGain = ac.createGain();
      revGain.gain.value = 0.4;
      reverb.connect(revGain);
      revGain.connect(comp);

      for (let i = 0; i < 4; i++) {
        const o1 = ac.createOscillator();
        const o2 = ac.createOscillator();
        const f = ac.createBiquadFilter();
        const g = ac.createGain();
        o1.type = 'sawtooth';
        o2.type = 'triangle';
        o2.detune.value = 6 + i * 2;
        f.type = 'lowpass';
        f.frequency.value = 350;
        f.Q.value = 0.8;
        g.gain.value = 0;
        o1.connect(f); o2.connect(f);
        f.connect(g);
        g.connect(master);
        g.connect(reverb);
        o1.start(); o2.start();
        padVoices.push({ o1, o2, f, g });
      }

      const lo1 = ac.createOscillator();
      const lo2 = ac.createOscillator();
      const lf = ac.createBiquadFilter();
      const lg = ac.createGain();
      lo1.type = 'square';
      lo2.type = 'sawtooth';
      lo2.detune.value = -4;
      lf.type = 'lowpass';
      lf.frequency.value = 1200;
      lf.Q.value = 5;
      lg.gain.value = 0;
      lo1.connect(lf); lo2.connect(lf);
      lf.connect(lg);
      lg.connect(master);
      lg.connect(delay);
      lg.connect(reverb);
      lo1.start(); lo2.start();
      lead = { o1: lo1, o2: lo2, f: lf, g: lg };

      const bo1 = ac.createOscillator();
      const bo2 = ac.createOscillator();
      const bf = ac.createBiquadFilter();
      const bg = ac.createGain();
      bo1.type = 'sine';
      bo2.type = 'triangle';
      bo2.detune.value = -1200;
      bf.type = 'lowpass';
      bf.frequency.value = 150;
      bg.gain.value = 0;
      bo1.connect(bf); bo2.connect(bf);
      bf.connect(bg);
      bg.connect(master);
      bo1.start(); bo2.start();
      bass = { o1: bo1, o2: bo2, f: bf, g: bg };

      const so1 = ac.createOscillator();
      const so2 = ac.createOscillator();
      const sf = ac.createBiquadFilter();
      const sg = ac.createGain();
      so1.type = 'sawtooth';
      so2.type = 'square';
      so2.detune.value = 5;
      sf.type = 'bandpass';
      sf.frequency.value = 1200;
      sf.Q.value = 3;
      sg.gain.value = 0;
      so1.connect(sf); so2.connect(sf);
      sf.connect(sg);
      sg.connect(master);
      sg.connect(delay);
      so1.start(); so2.start();
      stab = { o1: so1, o2: so2, f: sf, g: sg };
    }

    function triggerKick() {
      if (!ac) return;
      const t = ac.currentTime;
      const ko = ac.createOscillator();
      const kg = ac.createGain();
      ko.type = 'sine';
      ko.frequency.setValueAtTime(120, t);
      ko.frequency.exponentialRampToValueAtTime(35, t + 0.12);
      kg.gain.setValueAtTime(0.4, t);
      kg.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
      ko.connect(kg);
      kg.connect(master);
      ko.start(t);
      ko.stop(t + 0.3);
    }

    function detectGesture(hand) {
      if (!hand) return 'none';
      const ext = (tip, pip) => hand[tip].y < hand[pip].y;
      const thumb = ext(4, 3);
      const index = ext(8, 6);
      const middle = ext(12, 10);
      const ring = ext(16, 14);
      const pinky = ext(20, 18);

      if (thumb && !index && !middle && !ring && !pinky) return 'thumbsup';
      if (index && !middle && !ring && !pinky) return 'point';
      if (index && middle && !ring && !pinky) return 'peace';
      if (thumb && index && middle && ring && pinky) return 'palm';
      if (!thumb && !index && !middle && !ring && !pinky) return 'fist';
      return 'open';
    }

    function getHand(label) {
      for (let i = 0; i < hands.length; i++) {
        if (handedness[i] === label) return hands[i];
      }
      return null;
    }

    function updateAudio() {
      if (!ac) return;
      const t = ac.currentTime;
      const rHand = getHand('Right');
      const lHand = getHand('Left');
      const gesture = detectGesture(rHand);

      const gestureIcons = {
        thumbsup: '▲', peace: '✌', point: '☝', palm: '◎', fist: '●', open: '○', none: '—'
      };
      document.getElementById('gIcon').textContent = gestureIcons[gesture] || '○';
      document.getElementById('gName').textContent = gesture.toUpperCase();

      let chordIdx = 0;
      if (rHand && rHand[9]) {
        chordIdx = Math.floor(rHand[9].y * PROGRESSION.length);
        chordIdx = Math.max(0, Math.min(PROGRESSION.length - 1, chordIdx));
      }
      currentChord = PROGRESSION[chordIdx];
      const chord = CHORDS[currentChord];
      document.getElementById('hC').textContent = currentChord;

      // Expression from face
      if (faceLandmarks) {
        const mouth = faceLandmarks[13];
        const chin = faceLandmarks[152];
        if (mouth && chin) {
          const mouthOpen = Math.abs(mouth.y - chin.y);
          expressionMod = 0.3 + mouthOpen * 3;
          expressionMod = Math.min(1, Math.max(0.3, expressionMod));
        }
      }
      document.getElementById('hE').textContent = Math.round(expressionMod * 100) + '%';

      // Switch arp pattern based on left hand rotation/position
      if (lHand && t - arpSwitchTime > 2) {
        const wrist = lHand[0];
        const middle = lHand[9];
        const angle = Math.atan2(middle.y - wrist.y, middle.x - wrist.x);
        const patternIdx = Math.floor(((angle + Math.PI) / (Math.PI * 2)) * ARP_NAMES.length);
        const newPattern = ARP_NAMES[Math.abs(patternIdx) % ARP_NAMES.length];
        if (newPattern !== currentArpPattern) {
          currentArpPattern = newPattern;
          arpSwitchTime = t;
        }
      }
      document.getElementById('hP').textContent = currentArpPattern.toUpperCase();
      document.getElementById('arpName').textContent = currentArpPattern.toUpperCase();

      // Gesture triggers
      if (gesture === 'thumbsup' && lastGesture !== 'thumbsup') {
        triggerKick();
      }

      if (gesture === 'peace' && lastGesture !== 'peace') {
        chord.slice(0, 3).forEach((n, i) => {
          setTimeout(() => {
            const freq = mtof(ROOT + 12 + n);
            stab.o1.frequency.setTargetAtTime(freq, ac.currentTime, 0.005);
            stab.o2.frequency.setTargetAtTime(freq, ac.currentTime, 0.005);
            stab.g.gain.cancelScheduledValues(ac.currentTime);
            stab.g.gain.setValueAtTime(0.15, ac.currentTime);
            stab.g.gain.setTargetAtTime(0.001, ac.currentTime, 0.2);
          }, i * 40);
        });
        delayGain.gain.setTargetAtTime(0.45, t, 0.1);
      }

      if (gesture !== 'peace') {
        delayGain.gain.setTargetAtTime(0.2, t, 0.5);
      }

      if (gesture === 'point') {
        lead.f.Q.value = 7;
        lead.f.frequency.setTargetAtTime(2800, t, 0.08);
      } else {
        lead.f.Q.value = 4;
        lead.f.frequency.setTargetAtTime(1400, t, 0.15);
      }

      lastGesture = gesture;

      // Pad + Bass
      if (rHand && gesture !== 'fist') {
        const ry = rHand[9] ? rHand[9].y : 0.5;
        let filterFreq = 250 + (1 - ry) * 1200 * expressionMod;
        if (gesture === 'palm') filterFreq = 400 + (1 - ry) * 2500;

        const padGain = gesture === 'palm' ? 0.08 : 0.05;
        chord.forEach((note, i) => {
          if (!padVoices[i]) return;
          const freq = mtof(ROOT + note);
          padVoices[i].o1.frequency.setTargetAtTime(freq, t, 0.3);
          padVoices[i].o2.frequency.setTargetAtTime(freq, t, 0.3);
          padVoices[i].f.frequency.setTargetAtTime(filterFreq, t, 0.15);
          padVoices[i].g.gain.setTargetAtTime(padGain, t, 0.3);
        });

        const bassNote = chord[0] - 12;
        bass.o1.frequency.setTargetAtTime(mtof(ROOT + bassNote), t, 0.2);
        bass.o2.frequency.setTargetAtTime(mtof(ROOT + bassNote), t, 0.2);
        bass.g.gain.setTargetAtTime(0.12, t, 0.25);
      } else if (gesture === 'fist') {
        padVoices.forEach(v => {
          v.f.frequency.setTargetAtTime(120, t, 0.1);
          v.g.gain.setTargetAtTime(0.015, t, 0.2);
        });
        bass.g.gain.setTargetAtTime(0.04, t, 0.2);
      } else {
        padVoices.forEach(v => v.g.gain.setTargetAtTime(0, t, 0.6));
        bass.g.gain.setTargetAtTime(0, t, 0.5);
      }

      // Arpeggiator
      if (lHand && lHand[8]) {
        const tip = lHand[8];
        const bpm = 80 + tip.x * 160;
        const stepTime = 60 / bpm / 2;
        const filterFreq = 800 + (1 - tip.y) * 3000;

        document.getElementById('hB').textContent = Math.round(bpm);

        if (t - arpTime > stepTime) {
          arpTime = t;
          const pattern = ARP_PATTERNS[currentArpPattern](chord);
          const note = pattern[arpIndex % pattern.length];
          const freq = mtof(ROOT + 12 + note);

          lead.o1.frequency.setTargetAtTime(freq, t, 0.008);
          lead.o2.frequency.setTargetAtTime(freq, t, 0.008);
          lead.f.frequency.setTargetAtTime(filterFreq, t, 0.02);

          lead.g.gain.cancelScheduledValues(t);
          lead.g.gain.setValueAtTime(lead.g.gain.value, t);
          lead.g.gain.linearRampToValueAtTime(0.14 * expressionMod, t + 0.02);
          lead.g.gain.setTargetAtTime(0.001, t + 0.02, stepTime * 0.5);

          arpIndex++;
        }
      } else {
        lead.g.gain.setTargetAtTime(0, t, 0.25);
        document.getElementById('hB').textContent = '—';
      }
    }

    // ============ TRACKING ============
    let handsModel, faceModel;

    async function initTracking() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { width: 1280, height: 720, facingMode: 'user' }
      });
      video.srcObject = stream;
      await video.play();

      handsModel = new Hands({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}`
      });
      handsModel.setOptions({
        maxNumHands: 2,
        modelComplexity: 1,
        minDetectionConfidence: 0.6,
        minTrackingConfidence: 0.5
      });
      handsModel.onResults(r => {
        hands = r.multiHandLandmarks || [];
        handedness = (r.multiHandedness || []).map(h => h.label);
      });
      await handsModel.initialize();

      faceModel = new FaceMesh({
        locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh@0.4/${f}`
      });
      faceModel.setOptions({
        maxNumFaces: 1,
        refineLandmarks: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
      });
      faceModel.onResults(r => {
        faceLandmarks = r.multiFaceLandmarks?.[0] || null;
      });
      await faceModel.initialize();

      let frameNum = 0;
      async function process() {
        frameNum++;
        await handsModel.send({ image: video });
        if (frameNum % 3 === 0) {
          await faceModel.send({ image: video });
        }
        requestAnimationFrame(process);
      }
      process();
    }

    // ============ DRAWING ============
    function addTrace(x, y, col, size = 3) {
      traces.push({ x, y, col, age: 0, size });
      if (traces.length > 120) traces.shift();
    }

    function addParticle(x, y, col) {
      particles.push({
        x, y, col,
        vx: (Math.random() - 0.5) * 4,
        vy: (Math.random() - 0.5) * 4,
        life: 1
      });
      if (particles.length > 50) particles.shift();
    }

    function draw() {
      if (!W || !H) return;
      ctx.clearRect(0, 0, W, H);
      frameCount++;

      // Draw particles
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx;
        p.y += p.vy;
        p.life -= 0.02;
        if (p.life <= 0) {
          particles.splice(i, 1);
          continue;
        }
        ctx.fillStyle = `rgba(${p.col}, ${p.life * 0.5})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2 * p.life, 0, Math.PI * 2);
        ctx.fill();
      }

      // Draw traces
      for (let i = traces.length - 1; i >= 0; i--) {
        const tr = traces[i];
        tr.age++;
        if (tr.age > 40) {
          traces.splice(i, 1);
          continue;
        }
        const alpha = 1 - tr.age / 40;
        ctx.fillStyle = `rgba(${tr.col}, ${alpha * 0.5})`;
        ctx.fillRect(tr.x - tr.size/2, tr.y - tr.size/2, tr.size, tr.size);
      }

      // Draw face - SUBTLE
      if (faceLandmarks) {
        // Just a few key points, very subtle
        const col = '255, 255, 255';
        const keyPts = [1, 33, 263, 61, 291]; // nose, eyes, mouth corners

        ctx.fillStyle = `rgba(${col}, 0.15)`;
        keyPts.forEach(idx => {
          const pt = faceLandmarks[idx];
          if (!pt) return;
          ctx.beginPath();
          ctx.arc(pt.x * W, pt.y * H, 3, 0, Math.PI * 2);
          ctx.fill();
        });

        // Subtle face outline - just chin to ears
        ctx.strokeStyle = `rgba(${col}, 0.08)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        const jawline = [234, 93, 132, 58, 172, 136, 150, 149, 176, 148, 152, 377, 400, 378, 379, 365, 397, 288, 361, 323, 454];
        jawline.forEach((idx, i) => {
          const pt = faceLandmarks[idx];
          if (!pt) return;
          if (i === 0) ctx.moveTo(pt.x * W, pt.y * H);
          else ctx.lineTo(pt.x * W, pt.y * H);
        });
        ctx.stroke();
      }

      // Draw hands with more visual elements
      hands.forEach((hand, hi) => {
        const isRight = handedness[hi] === 'Right';
        const col = isRight ? '255, 77, 0' : '0, 71, 255';

        // Traces from all fingertips
        [4, 8, 12, 16, 20].forEach(i => {
          if (hand[i]) {
            addTrace(hand[i].x * W, hand[i].y * H, col, isRight ? 4 : 3);
            // Particles on movement
            if (frameCount % 5 === 0) {
              addParticle(hand[i].x * W, hand[i].y * H, col);
            }
          }
        });

        // Skeleton with varying opacity
        const bones = [
          [0,1],[1,2],[2,3],[3,4],
          [0,5],[5,6],[6,7],[7,8],
          [5,9],[9,10],[10,11],[11,12],
          [9,13],[13,14],[14,15],[15,16],
          [13,17],[17,18],[18,19],[19,20],
          [0,17]
        ];

        // Draw bones
        ctx.strokeStyle = `rgba(${col}, 0.4)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        bones.forEach(([a, b]) => {
          ctx.moveTo(hand[a].x * W, hand[a].y * H);
          ctx.lineTo(hand[b].x * W, hand[b].y * H);
        });
        ctx.stroke();

        // Finger group bounding boxes
        const fingerGroups = [
          { name: 'THUMB', pts: [1,2,3,4] },
          { name: 'INDEX', pts: [5,6,7,8] },
          { name: 'MIDDLE', pts: [9,10,11,12] },
          { name: 'RING', pts: [13,14,15,16] },
          { name: 'PINKY', pts: [17,18,19,20] }
        ];

        fingerGroups.forEach((fg, fi) => {
          let fx1 = Infinity, fy1 = Infinity, fx2 = -Infinity, fy2 = -Infinity;
          fg.pts.forEach(idx => {
            fx1 = Math.min(fx1, hand[idx].x * W);
            fy1 = Math.min(fy1, hand[idx].y * H);
            fx2 = Math.max(fx2, hand[idx].x * W);
            fy2 = Math.max(fy2, hand[idx].y * H);
          });
          ctx.strokeStyle = `rgba(${col}, 0.15)`;
          ctx.strokeRect(fx1 - 3, fy1 - 3, fx2 - fx1 + 6, fy2 - fy1 + 6);
        });

        // Landmark points
        hand.forEach((pt, i) => {
          const x = pt.x * W, y = pt.y * H;
          const isTip = [4, 8, 12, 16, 20].includes(i);

          ctx.fillStyle = `rgba(${col}, ${isTip ? 0.9 : 0.5})`;
          ctx.beginPath();
          ctx.arc(x, y, isTip ? 5 : 2, 0, Math.PI * 2);
          ctx.fill();

          if (isTip) {
            // Crosshair on tips
            ctx.strokeStyle = `rgba(${col}, 0.6)`;
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x - 10, y); ctx.lineTo(x + 10, y);
            ctx.moveTo(x, y - 10); ctx.lineTo(x, y + 10);
            ctx.stroke();

            // ID label
            ctx.fillStyle = `rgba(${col}, 0.7)`;
            ctx.font = '8px IBM Plex Mono';
            ctx.fillText(`${i}`, x + 12, y - 4);
          }
        });

        // Main hand bounding box
        let x1 = Infinity, y1 = Infinity, x2 = -Infinity, y2 = -Infinity;
        hand.forEach(p => {
          x1 = Math.min(x1, p.x * W);
          y1 = Math.min(y1, p.y * H);
          x2 = Math.max(x2, p.x * W);
          y2 = Math.max(y2, p.y * H);
        });

        // Double box effect
        ctx.strokeStyle = `rgba(${col}, 0.3)`;
        ctx.strokeRect(x1 - 25, y1 - 25, x2 - x1 + 50, y2 - y1 + 50);
        ctx.strokeStyle = `rgba(${col}, 0.6)`;
        ctx.strokeRect(x1 - 15, y1 - 15, x2 - x1 + 30, y2 - y1 + 30);

        // Label
        ctx.fillStyle = `rgba(${col}, 0.8)`;
        ctx.font = '9px IBM Plex Mono';
        ctx.fillText(`${isRight ? 'R' : 'L'}_HAND`, x1 - 15, y1 - 20);

        // Coordinate readout
        ctx.fillStyle = `rgba(${col}, 0.5)`;
        ctx.font = '7px IBM Plex Mono';
        const cx = ((x1 + x2) / 2 / W).toFixed(2);
        const cy = ((y1 + y2) / 2 / H).toFixed(2);
        ctx.fillText(`X:${cx} Y:${cy}`, x1 - 15, y2 + 30);
      });

      // Connection line between hands
      if (hands.length === 2 && hands[0][9] && hands[1][9]) {
        const h0 = hands[0][9], h1 = hands[1][9];
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.setLineDash([4, 6]);
        ctx.beginPath();
        ctx.moveTo(h0.x * W, h0.y * H);
        ctx.lineTo(h1.x * W, h1.y * H);
        ctx.stroke();
        ctx.setLineDash([]);

        // Distance indicator
        const dist = Math.hypot((h1.x - h0.x) * W, (h1.y - h0.y) * H);
        const midX = (h0.x + h1.x) / 2 * W;
        const midY = (h0.y + h1.y) / 2 * H;
        ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
        ctx.font = '7px IBM Plex Mono';
        ctx.fillText(`${Math.round(dist)}px`, midX, midY - 5);
      }

      // Frame counter
      ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
      ctx.font = '7px IBM Plex Mono';
      ctx.fillText(`F:${String(frameCount).padStart(5, '0')}`, 12, H - 12);
    }

    function loop() {
      draw();
      updateAudio();
      requestAnimationFrame(loop);
    }

    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;
    }

    async function begin() {
      startEl.classList.add('hide');
      resize();
      await initTracking();
      initAudio();
      document.getElementById('hud').style.display = 'block';
      document.getElementById('gesture').style.display = 'block';
      document.getElementById('guide').style.display = 'block';
      document.getElementById('arp-mode').style.display = 'block';
      loop();
    }

    startEl.onclick = begin;
    window.onresize = resize;
  </script>
</body>
</html>
