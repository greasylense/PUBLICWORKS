<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Somatic Interface — PUBLICWORKS</title>
  <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400&display=swap" rel="stylesheet">
  <style>
    *{margin:0;padding:0;box-sizing:border-box}
    body{font-family:'IBM Plex Mono',monospace;background:#080808;color:#e0e0e0;overflow:hidden}
    #back{position:fixed;top:1.5rem;left:1.5rem;font-size:0.7rem;color:#555;text-decoration:none;z-index:999}
    #back:hover{color:#fff}
    #start{position:fixed;inset:0;background:#080808;display:flex;flex-direction:column;align-items:center;justify-content:center;z-index:900;cursor:pointer;transition:opacity 0.5s}
    #start.hide{opacity:0;pointer-events:none}
    #start h1{font-size:2.2rem;font-weight:400;letter-spacing:-0.02em}
    #start .sub{font-size:0.7rem;color:#555;margin-bottom:0.5rem}
    #start .desc{max-width:340px;text-align:center;margin:1.2rem;font-size:0.75rem;color:#555;line-height:1.6}
    #start .cta{font-size:0.6rem;color:#555;text-transform:uppercase;letter-spacing:0.15em}
    #video{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;transform:scaleX(-1);opacity:0.7}
    #canvas{position:fixed;inset:0;width:100%;height:100%;pointer-events:none;transform:scaleX(-1)}
    #hud{position:fixed;bottom:1.5rem;right:1.5rem;font-size:0.5rem;color:#777;background:rgba(0,0,0,0.6);padding:0.4rem 0.6rem;border:1px solid #333;z-index:999}
    #hud div{margin-bottom:0.08rem}
    #gesture{position:fixed;top:1.5rem;right:1.5rem;font-size:0.6rem;color:#c86;background:rgba(0,0,0,0.6);padding:0.4rem 0.6rem;border:1px solid #533;z-index:999}
  </style>
</head>
<body>
  <a href="../../" id="back">← PUBLICWORKS</a>
  <div id="start">
    <div class="sub">005</div>
    <h1>Somatic Interface</h1>
    <p class="desc">Right hand: harmony + gestures. Left hand: melody. Open palm, point, thumbs up — each triggers different sounds.</p>
    <p class="cta">Click to begin</p>
  </div>
  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>
  <div id="hud" style="display:none">
    <div>CHORD: <span id="hC">I</span></div>
    <div>L: <span id="hL">--</span> R: <span id="hR">--</span></div>
  </div>
  <div id="gesture" style="display:none">GESTURE: <span id="hG">--</span></div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const startEl = document.getElementById('start');

    let W, H, hands = [], handedness = [], frameId = 18300;
    const traces = [];

    // ============ AUDIO ENGINE - Fred Again Style ============
    let ac, master, comp, delay, delayGain, reverb, revGain;
    let pad = [], lead, bass, stab, kick;
    let arpT = 0, arpI = 0, lastGesture = '', gestureTime = 0;

    const CHORDS = {
      I: [0,4,7,11],    // Cmaj7
      ii: [2,5,9,12],   // Dm7
      IV: [5,9,12,16],  // Fmaj7
      V: [7,11,14,17],  // G7
      vi: [9,12,16,19]  // Am7
    };
    const CL = ['I','vi','IV','V','I'];
    const ROOT = 48;
    const mtof = m => 440 * Math.pow(2, (m-69)/12);

    function initAudio() {
      ac = new AudioContext();

      // Compressor for that pumping feel
      comp = ac.createDynamicsCompressor();
      comp.threshold.value = -20;
      comp.knee.value = 10;
      comp.ratio.value = 8;
      comp.attack.value = 0.005;
      comp.release.value = 0.1;
      comp.connect(ac.destination);

      master = ac.createGain();
      master.gain.value = 0.6;
      master.connect(comp);

      // Ping-pong delay
      delay = ac.createDelay(1);
      delay.delayTime.value = 0.3;
      const delayFb = ac.createGain();
      delayFb.gain.value = 0.4;
      const delayFilter = ac.createBiquadFilter();
      delayFilter.type = 'lowpass';
      delayFilter.frequency.value = 2500;
      delay.connect(delayFilter);
      delayFilter.connect(delayFb);
      delayFb.connect(delay);
      delayGain = ac.createGain();
      delayGain.gain.value = 0.3;
      delay.connect(delayGain);
      delayGain.connect(comp);

      // Lush reverb
      reverb = ac.createConvolver();
      const revLen = ac.sampleRate * 2.5;
      const imp = ac.createBuffer(2, revLen, ac.sampleRate);
      for (let c = 0; c < 2; c++) {
        const d = imp.getChannelData(c);
        for (let i = 0; i < revLen; i++) d[i] = (Math.random()*2-1) * Math.pow(1-i/revLen, 1.5);
      }
      reverb.buffer = imp;
      revGain = ac.createGain();
      revGain.gain.value = 0.35;
      reverb.connect(revGain);
      revGain.connect(comp);

      // Warm pad (4 voices, detuned)
      for (let i = 0; i < 4; i++) {
        const o1 = ac.createOscillator();
        const o2 = ac.createOscillator();
        const f = ac.createBiquadFilter();
        const g = ac.createGain();
        o1.type = 'sawtooth';
        o2.type = 'sawtooth';
        o2.detune.value = 8;
        f.type = 'lowpass';
        f.frequency.value = 400;
        f.Q.value = 1;
        g.gain.value = 0;
        o1.connect(f); o2.connect(f);
        f.connect(g);
        g.connect(master);
        g.connect(reverb);
        o1.start(); o2.start();
        pad.push({o1, o2, f, g});
      }

      // Plucky lead
      const lo = ac.createOscillator();
      const lo2 = ac.createOscillator();
      const lf = ac.createBiquadFilter();
      const lg = ac.createGain();
      lo.type = 'square';
      lo2.type = 'sawtooth';
      lo2.detune.value = -5;
      lf.type = 'lowpass';
      lf.frequency.value = 800;
      lf.Q.value = 6;
      lg.gain.value = 0;
      lo.connect(lf); lo2.connect(lf);
      lf.connect(lg);
      lg.connect(master);
      lg.connect(delay);
      lg.connect(reverb);
      lo.start(); lo2.start();
      lead = {o: lo, o2: lo2, f: lf, g: lg};

      // Deep bass
      const bo = ac.createOscillator();
      const bo2 = ac.createOscillator();
      const bf = ac.createBiquadFilter();
      const bg = ac.createGain();
      bo.type = 'sine';
      bo2.type = 'triangle';
      bo2.detune.value = -1200;
      bf.type = 'lowpass';
      bf.frequency.value = 120;
      bg.gain.value = 0;
      bo.connect(bf); bo2.connect(bf);
      bf.connect(bg);
      bg.connect(master);
      bo.start(); bo2.start();
      bass = {o: bo, o2: bo2, f: bf, g: bg};

      // Stab synth (for gestures)
      const so = ac.createOscillator();
      const so2 = ac.createOscillator();
      const sf = ac.createBiquadFilter();
      const sg = ac.createGain();
      so.type = 'sawtooth';
      so2.type = 'square';
      so2.detune.value = 7;
      sf.type = 'bandpass';
      sf.frequency.value = 1000;
      sf.Q.value = 2;
      sg.gain.value = 0;
      so.connect(sf); so2.connect(sf);
      sf.connect(sg);
      sg.connect(master);
      sg.connect(delay);
      so.start(); so2.start();
      stab = {o: so, o2: so2, f: sf, g: sg};

      // Kick (for thumbs up)
      kick = {
        trigger: (t) => {
          const ko = ac.createOscillator();
          const kg = ac.createGain();
          ko.type = 'sine';
          ko.frequency.setValueAtTime(150, t);
          ko.frequency.exponentialRampToValueAtTime(40, t + 0.1);
          kg.gain.setValueAtTime(0.5, t);
          kg.gain.exponentialRampToValueAtTime(0.01, t + 0.2);
          ko.connect(kg);
          kg.connect(master);
          ko.start(t);
          ko.stop(t + 0.2);
        }
      };
    }

    // Gesture detection
    function detectGesture(hand) {
      if (!hand) return 'none';

      const dominated = (tip, pip) => hand[tip].y < hand[pip].y;
      const thumb = dominated(4, 3);
      const index = dominated(8, 6);
      const middle = dominated(12, 10);
      const ring = dominated(16, 14);
      const pinky = dominated(20, 18);

      // Thumbs up: only thumb extended
      if (thumb && !index && !middle && !ring && !pinky) return 'thumbsup';
      // Point: only index extended
      if (index && !middle && !ring && !pinky) return 'point';
      // Peace: index + middle
      if (index && middle && !ring && !pinky) return 'peace';
      // Open palm: all extended
      if (thumb && index && middle && ring && pinky) return 'palm';
      // Fist: none extended
      if (!thumb && !index && !middle && !ring && !pinky) return 'fist';

      return 'other';
    }

    function getHand(label) {
      for (let i = 0; i < hands.length; i++) {
        if (handedness[i] === label) return hands[i];
      }
      return null;
    }

    function updateAudio() {
      if (!ac) return;
      const t = ac.currentTime;
      const rHand = getHand('Right');
      const lHand = getHand('Left');

      // Detect gesture on right hand
      const gesture = detectGesture(rHand);
      document.getElementById('hG').textContent = gesture.toUpperCase();

      // Chord from right hand Y
      let ci = 2;
      if (rHand && rHand[8]) {
        ci = Math.floor(rHand[8].y * CL.length);
        ci = Math.max(0, Math.min(CL.length - 1, ci));
        document.getElementById('hR').textContent = gesture;
      } else {
        document.getElementById('hR').textContent = '--';
      }
      const chordName = CL[ci];
      const chord = CHORDS[chordName];
      document.getElementById('hC').textContent = chordName;

      // === GESTURE EFFECTS ===

      // Thumbs up = kick hit
      if (gesture === 'thumbsup' && lastGesture !== 'thumbsup') {
        kick.trigger(t);
      }

      // Palm = filter sweep up + full pad
      if (gesture === 'palm' && rHand) {
        const sweep = 400 + (1 - rHand[0].y) * 2000;
        pad.forEach((p, i) => {
          p.f.frequency.setTargetAtTime(sweep, t, 0.05);
          p.g.gain.setTargetAtTime(0.1, t, 0.1);
        });
      }

      // Fist = mute/filter down
      if (gesture === 'fist') {
        pad.forEach(p => {
          p.f.frequency.setTargetAtTime(150, t, 0.05);
          p.g.gain.setTargetAtTime(0.02, t, 0.1);
        });
      }

      // Peace = stab chord + extra delay
      if (gesture === 'peace' && lastGesture !== 'peace') {
        chord.slice(0, 3).forEach((n, i) => {
          setTimeout(() => {
            const freq = mtof(ROOT + 12 + n);
            stab.o.frequency.setTargetAtTime(freq, ac.currentTime, 0.01);
            stab.o2.frequency.setTargetAtTime(freq, ac.currentTime, 0.01);
            stab.g.gain.cancelScheduledValues(ac.currentTime);
            stab.g.gain.setValueAtTime(0.2, ac.currentTime);
            stab.g.gain.exponentialRampToValueAtTime(0.01, ac.currentTime + 0.3);
          }, i * 50);
        });
        delayGain.gain.setTargetAtTime(0.5, t, 0.1);
      } else if (gesture !== 'peace') {
        delayGain.gain.setTargetAtTime(0.25, t, 0.3);
      }

      // Point = lead solo mode (brighter filter)
      if (gesture === 'point') {
        lead.f.Q.value = 8;
        lead.f.frequency.setTargetAtTime(2500, t, 0.05);
      } else {
        lead.f.Q.value = 4;
      }

      lastGesture = gesture;

      // === PAD + BASS (right hand presence) ===
      if (rHand && gesture !== 'fist') {
        const ry = rHand[8] ? rHand[8].y : 0.5;
        const filt = gesture === 'palm' ? 400 + (1-ry)*2000 : 300 + (1-ry)*800;

        chord.forEach((n, i) => {
          if (!pad[i]) return;
          const freq = mtof(ROOT + n);
          pad[i].o1.frequency.setTargetAtTime(freq, t, 0.15);
          pad[i].o2.frequency.setTargetAtTime(freq, t, 0.15);
          if (gesture !== 'palm' && gesture !== 'fist') {
            pad[i].f.frequency.setTargetAtTime(filt, t, 0.1);
            pad[i].g.gain.setTargetAtTime(0.06, t, 0.2);
          }
        });

        bass.o.frequency.setTargetAtTime(mtof(ROOT + chord[0] - 12), t, 0.1);
        bass.o2.frequency.setTargetAtTime(mtof(ROOT + chord[0] - 12), t, 0.1);
        bass.g.gain.setTargetAtTime(0.18, t, 0.15);
      } else {
        pad.forEach(p => p.g.gain.setTargetAtTime(0, t, 0.4));
        bass.g.gain.setTargetAtTime(0, t, 0.3);
      }

      // === ARPEGGIATOR (left hand) ===
      if (lHand && lHand[8]) {
        document.getElementById('hL').textContent = 'ARP';
        const tip = lHand[8];
        const bpm = 100 + tip.x * 120;
        const step = 60 / bpm / 2;
        const filt = 600 + (1 - tip.y) * 3500;

        if (t - arpT > step) {
          arpT = t;
          const pat = [...chord, chord[0] + 12, chord[2] + 12];
          const note = pat[arpI % pat.length];
          const freq = mtof(ROOT + 12 + note);

          lead.o.frequency.setTargetAtTime(freq, t, 0.01);
          lead.o2.frequency.setTargetAtTime(freq, t, 0.01);
          lead.f.frequency.setTargetAtTime(filt, t, 0.02);
          lead.g.gain.cancelScheduledValues(t);
          lead.g.gain.setValueAtTime(0.18, t);
          lead.g.gain.exponentialRampToValueAtTime(0.01, t + step * 0.7);
          arpI++;
        }
      } else {
        document.getElementById('hL').textContent = '--';
        lead.g.gain.setTargetAtTime(0, t, 0.15);
      }
    }

    // ============ TRACKING ============
    async function initTracking() {
      const stream = await navigator.mediaDevices.getUserMedia({video: {width: 1280, height: 720}});
      video.srcObject = stream;
      await video.play();

      const hm = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}`});
      hm.setOptions({maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5});
      hm.onResults(r => {
        hands = r.multiHandLandmarks || [];
        handedness = (r.multiHandedness || []).map(h => h.label);
      });
      await hm.initialize();

      (async function proc() {
        await hm.send({image: video});
        requestAnimationFrame(proc);
      })();
    }

    // ============ DRAWING - Optimized ============
    function addTrace(x, y, col) {
      traces.push({x, y, col, age: 0});
      if (traces.length > 100) traces.shift();
    }

    function draw() {
      ctx.fillStyle = 'rgba(8,8,8,0.2)';
      ctx.fillRect(0, 0, W, H);
      frameId++;

      // Traces
      for (let i = traces.length - 1; i >= 0; i--) {
        const tr = traces[i];
        tr.age++;
        if (tr.age > 60) { traces.splice(i, 1); continue; }
        const a = 1 - tr.age / 60;
        ctx.fillStyle = `rgba(${tr.col},${a * 0.8})`;
        ctx.fillRect(tr.x - 1, tr.y - 1, 2, 2);
      }

      // Hands
      hands.forEach((hand, hi) => {
        const isRight = handedness[hi] === 'Right';
        const col = isRight ? '200,90,110' : '180,180,180';

        // Add traces
        [0, 4, 8, 12, 16, 20].forEach(i => {
          if (hand[i]) addTrace(hand[i].x * W, hand[i].y * H, col);
        });

        // Skeleton
        const bones = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
        ctx.strokeStyle = `rgba(${col},0.4)`;
        ctx.lineWidth = 1;
        ctx.beginPath();
        bones.forEach(([a, b]) => {
          ctx.moveTo(hand[a].x * W, hand[a].y * H);
          ctx.lineTo(hand[b].x * W, hand[b].y * H);
        });
        ctx.stroke();

        // Points
        hand.forEach((pt, i) => {
          const x = pt.x * W, y = pt.y * H;
          const isTip = [4, 8, 12, 16, 20].includes(i);
          ctx.fillStyle = `rgb(${col})`;
          ctx.beginPath();
          ctx.arc(x, y, isTip ? 5 : 2, 0, Math.PI * 2);
          ctx.fill();

          if (isTip) {
            ctx.strokeStyle = `rgb(${col})`;
            ctx.strokeRect(x - 7, y - 7, 14, 14);
            ctx.fillStyle = `rgba(${col},0.7)`;
            ctx.font = '8px IBM Plex Mono';
            ctx.fillText(frameId + i, x + 9, y - 3);
          }
        });

        // Bounding box
        let x1 = Infinity, y1 = Infinity, x2 = -Infinity, y2 = -Infinity;
        hand.forEach(p => {
          x1 = Math.min(x1, p.x * W); y1 = Math.min(y1, p.y * H);
          x2 = Math.max(x2, p.x * W); y2 = Math.max(y2, p.y * H);
        });
        ctx.strokeStyle = `rgb(${col})`;
        ctx.lineWidth = 1;
        ctx.strokeRect(x1 - 20, y1 - 20, x2 - x1 + 40, y2 - y1 + 40);
        ctx.fillStyle = `rgb(${col})`;
        ctx.font = '9px IBM Plex Mono';
        ctx.fillText(`${isRight ? 'R' : 'L'}_HAND`, x1 - 20, y1 - 25);
      });

      // Connect hands
      if (hands.length === 2 && hands[0][8] && hands[1][8]) {
        ctx.strokeStyle = 'rgba(150,150,150,0.2)';
        ctx.setLineDash([3, 3]);
        ctx.beginPath();
        ctx.moveTo(hands[0][8].x * W, hands[0][8].y * H);
        ctx.lineTo(hands[1][8].x * W, hands[1][8].y * H);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      // Frame counter
      ctx.fillStyle = '#333';
      ctx.font = '8px IBM Plex Mono';
      ctx.fillText(`F:${frameId}`, 10, H - 10);
    }

    function loop() {
      draw();
      updateAudio();
      requestAnimationFrame(loop);
    }

    function resize() {
      W = window.innerWidth;
      H = window.innerHeight;
      canvas.width = W;
      canvas.height = H;
    }

    async function begin() {
      startEl.classList.add('hide');
      resize();
      await initTracking();
      initAudio();
      document.getElementById('hud').style.display = 'block';
      document.getElementById('gesture').style.display = 'block';
      loop();
    }

    startEl.onclick = begin;
    window.onresize = resize;
  </script>
</body>
</html>
