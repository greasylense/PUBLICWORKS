<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Somatic Interface — PUBLICWORKS</title>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;700&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg: #D1D1D1;
      --text: #0F0F0F;
      --dim: #6E6E6E;
      --accent: #0047FF;
      --alert: #FF4D00;
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: 'IBM Plex Mono', monospace; background: #000; overflow: hidden; }

    #start {
      position: fixed; inset: 0; background: var(--bg);
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      z-index: 100; cursor: pointer;
    }
    #start.hide { display: none; }
    #start h1 { font-family: 'Space Grotesk', sans-serif; font-size: 2.5rem; font-weight: 700; color: var(--text); }
    #start .sub { font-size: 0.7rem; color: var(--dim); margin-top: 0.5rem; }
    #start .cta { margin-top: 2rem; padding: 0.8rem 2rem; border: 1px solid var(--text); font-size: 0.75rem; }
    #start .cta:hover { background: var(--text); color: var(--bg); }

    #back { position: fixed; top: 1rem; left: 1rem; font-size: 0.7rem; color: #fff; text-decoration: none; z-index: 99; opacity: 0.6; }
    #back:hover { opacity: 1; }

    video { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; object-fit: cover; transform: scaleX(-1); }
    canvas { position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; }

    .panel {
      position: fixed; background: rgba(0,0,0,0.85); color: #fff;
      font-size: 0.6rem; padding: 0.8rem; border: 1px solid rgba(255,255,255,0.15);
    }
    #info-panel { bottom: 1rem; left: 1rem; border-color: rgba(255,255,255,0.3); }
    #info-panel .row { margin-bottom: 0.2rem; opacity: 0.7; }

    #status { position: fixed; top: 1rem; left: 50%; transform: translateX(-50%); letter-spacing: 0.1em; }
  </style>
</head>
<body>
  <a href="../../" id="back" style="display:none">← PUBLICWORKS</a>

  <div id="start">
    <h1>Somatic Interface</h1>
    <p class="sub">005 — Move your hands to make music</p>
    <div class="cta">Enter</div>
  </div>

  <video id="video" autoplay playsinline></video>
  <canvas id="canvas"></canvas>

  <div id="info-panel" class="panel" style="display:none">
    <div class="row">Move right hand → play notes</div>
    <div class="row">Height → pitch &nbsp;|&nbsp; Side → tempo</div>
    <div class="row">Left fist → mute</div>
  </div>

  <div id="status" class="panel" style="display:none">
    <span id="statusText">READY</span>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    let W, H;
    let hands = [], handedness = [];

    // ═══════════════════════════════════════════════════════════════
    // AUDIO ENGINE — Chill, ambient, easy
    // ═══════════════════════════════════════════════════════════════
    let ac, master, delay, reverb, globalFilter, analyser;
    let pad, lead;
    let arpTime = 0, arpIndex = 0;
    let isMuted = false;
    let freqData, audioLevel = 0, smoothLevel = 0;

    // Pentatonic — always sounds good
    const SCALE = [0, 2, 4, 7, 9, 12, 14, 16, 19, 21];
    const ROOT = 48;
    const mtof = m => 440 * Math.pow(2, (m - 69) / 12);

    function initAudio() {
      ac = new AudioContext();

      // Analyser
      analyser = ac.createAnalyser();
      analyser.fftSize = 256;
      analyser.smoothingTimeConstant = 0.85;
      freqData = new Uint8Array(analyser.frequencyBinCount);

      // Master with soft limiting
      master = ac.createGain();
      master.gain.value = 0.4;
      master.connect(analyser);
      analyser.connect(ac.destination);

      // Global filter
      globalFilter = ac.createBiquadFilter();
      globalFilter.type = 'lowpass';
      globalFilter.frequency.value = 2000;
      globalFilter.Q.value = 0.5;
      globalFilter.connect(master);

      // Gentle delay
      delay = ac.createDelay(1);
      delay.delayTime.value = 0.5;
      const fb = ac.createGain();
      fb.gain.value = 0.3;
      const delayFilter = ac.createBiquadFilter();
      delayFilter.type = 'lowpass';
      delayFilter.frequency.value = 1500;
      delay.connect(delayFilter);
      delayFilter.connect(fb);
      fb.connect(delay);
      const delayOut = ac.createGain();
      delayOut.gain.value = 0.4;
      delay.connect(delayOut);
      delayOut.connect(master);

      // Big soft reverb
      reverb = ac.createConvolver();
      const len = ac.sampleRate * 3;
      const imp = ac.createBuffer(2, len, ac.sampleRate);
      for (let c = 0; c < 2; c++) {
        const d = imp.getChannelData(c);
        for (let i = 0; i < len; i++) {
          d[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / len, 2);
        }
      }
      reverb.buffer = imp;
      const revOut = ac.createGain();
      revOut.gain.value = 0.5;
      reverb.connect(revOut);
      revOut.connect(master);

      // ═══════════════════════════════════════════
      // PAD — Simple, warm, two oscillators
      // ═══════════════════════════════════════════
      const padOsc1 = ac.createOscillator();
      const padOsc2 = ac.createOscillator();
      const padFilter = ac.createBiquadFilter();
      const padGain = ac.createGain();

      padOsc1.type = 'sine';
      padOsc2.type = 'triangle';
      padOsc2.detune.value = 5;
      padFilter.type = 'lowpass';
      padFilter.frequency.value = 800;
      padGain.gain.value = 0;

      padOsc1.connect(padFilter);
      padOsc2.connect(padFilter);
      padFilter.connect(padGain);
      padGain.connect(globalFilter);
      padGain.connect(reverb);
      padOsc1.start();
      padOsc2.start();

      pad = { osc1: padOsc1, osc2: padOsc2, filter: padFilter, gain: padGain };

      // ═══════════════════════════════════════════
      // LEAD — Soft plucky sound
      // ═══════════════════════════════════════════
      const leadOsc = ac.createOscillator();
      const leadOsc2 = ac.createOscillator();
      const leadFilter = ac.createBiquadFilter();
      const leadGain = ac.createGain();

      leadOsc.type = 'triangle';
      leadOsc2.type = 'sine';
      leadOsc2.detune.value = 3;
      leadFilter.type = 'lowpass';
      leadFilter.frequency.value = 1200;
      leadFilter.Q.value = 2;
      leadGain.gain.value = 0;

      leadOsc.connect(leadFilter);
      leadOsc2.connect(leadFilter);
      leadFilter.connect(leadGain);
      leadGain.connect(globalFilter);
      leadGain.connect(delay);
      leadGain.connect(reverb);
      leadOsc.start();
      leadOsc2.start();

      lead = { osc: leadOsc, osc2: leadOsc2, filter: leadFilter, gain: leadGain };
    }

    function getHand(label) {
      for (let i = 0; i < hands.length; i++) {
        if (handedness[i] === label) return hands[i];
      }
      return null;
    }

    // ═══════════════════════════════════════════════════════════════
    // AUDIO UPDATE — Simple and musical
    // ═══════════════════════════════════════════════════════════════
    function updateAudio() {
      if (!ac) return;
      const t = ac.currentTime;
      const lHand = getHand('Left');
      const rHand = getHand('Right');

      // Get audio level for visuals
      if (analyser) {
        analyser.getByteFrequencyData(freqData);
        let sum = 0;
        for (let i = 0; i < 32; i++) sum += freqData[i];
        audioLevel = sum / (32 * 255);
        smoothLevel += (audioLevel - smoothLevel) * 0.1;
      }

      // Left hand: fist = mute
      if (lHand) {
        const fist = lHand[8].y > lHand[6].y && lHand[12].y > lHand[10].y;
        if (fist && !isMuted) {
          isMuted = true;
          master.gain.setTargetAtTime(0.02, t, 0.05);
          document.getElementById('statusText').textContent = 'MUTED';
        } else if (!fist && isMuted) {
          isMuted = false;
          master.gain.setTargetAtTime(0.4, t, 0.1);
        }
      }

      // Right hand controls everything
      if (rHand && !isMuted) {
        const y = rHand[9].y; // palm center height
        const x = rHand[9].x; // palm center horizontal

        document.getElementById('statusText').textContent = 'PLAYING';

        // Pad plays root note based on height
        const padNote = SCALE[Math.floor((1 - y) * 5)];
        const padFreq = mtof(ROOT + padNote);
        pad.osc1.frequency.setTargetAtTime(padFreq, t, 0.3);
        pad.osc2.frequency.setTargetAtTime(padFreq, t, 0.3);
        pad.filter.frequency.setTargetAtTime(400 + (1 - y) * 800, t, 0.1);
        pad.gain.gain.setTargetAtTime(0.12, t, 0.5);

        // Arpeggiator speed from X position
        const bpm = 60 + x * 80; // 60-140 bpm
        const step = 60 / bpm / 2; // 8th notes

        if (t - arpTime > step) {
          arpTime = t;

          // Note from scale, offset by hand height
          const baseIdx = Math.floor((1 - y) * 5);
          const pattern = [0, 2, 1, 3, 2, 4, 3, 2];
          const noteIdx = (baseIdx + pattern[arpIndex % pattern.length]) % SCALE.length;
          const freq = mtof(ROOT + 12 + SCALE[noteIdx]);

          lead.osc.frequency.setTargetAtTime(freq, t, 0.01);
          lead.osc2.frequency.setTargetAtTime(freq, t, 0.01);

          // Soft attack and release
          lead.filter.frequency.setValueAtTime(1500 + (1 - y) * 1000, t);
          lead.filter.frequency.setTargetAtTime(600, t + step * 0.3, step * 0.2);
          lead.gain.gain.setValueAtTime(0.15, t);
          lead.gain.gain.setTargetAtTime(0, t + step * 0.6, step * 0.3);

          arpIndex++;
        }

        // Filter opens with height
        globalFilter.frequency.setTargetAtTime(800 + (1 - y) * 3000, t, 0.1);

      } else if (!isMuted) {
        document.getElementById('statusText').textContent = rHand ? 'PLAYING' : 'READY';
        pad.gain.gain.setTargetAtTime(0, t, 0.5);
        lead.gain.gain.setTargetAtTime(0, t, 0.3);
      }
    }

    // ═══════════════════════════════════════════════════════════════
    // DRAWING — TouchDesigner style, audio-reactive lines
    // ═══════════════════════════════════════════════════════════════
    let trails = []; // Store trail points

    function draw() {
      // Fade previous frame for trails
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, W, H);

      const intensity = smoothLevel * 2 + 0.3; // Audio reactivity

      hands.forEach((hand, hi) => {
        const isRight = handedness[hi] === 'Right';
        const baseColor = isRight ? [255, 77, 0] : [0, 71, 255]; // RGB values

        // Convert to screen coords (mirrored)
        const pts = hand.map(p => ({ x: (1 - p.x) * W, y: p.y * H }));
        const palm = pts[9];
        const wrist = pts[0];

        // ═══════════════════════════════════════════
        // CONCENTRIC CIRCLES around palm — pulse with audio
        // ═══════════════════════════════════════════
        const maxRadius = 80 + smoothLevel * 120;
        for (let r = 20; r < maxRadius; r += 25) {
          const alpha = (1 - r / maxRadius) * 0.4 * intensity;
          ctx.strokeStyle = `rgba(${baseColor.join(',')}, ${alpha})`;
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.arc(palm.x, palm.y, r + smoothLevel * 20, 0, Math.PI * 2);
          ctx.stroke();
        }

        // ═══════════════════════════════════════════
        // RADIAL LINES from palm — react to audio
        // ═══════════════════════════════════════════
        const numRays = 12;
        const rayLength = 60 + smoothLevel * 100;
        ctx.strokeStyle = `rgba(${baseColor.join(',')}, ${0.3 * intensity})`;
        ctx.lineWidth = 1;
        for (let i = 0; i < numRays; i++) {
          const angle = (i / numRays) * Math.PI * 2 + performance.now() * 0.0005;
          const len = rayLength * (0.5 + (freqData ? freqData[i * 4] / 255 : 0.5) * 0.5);
          ctx.beginPath();
          ctx.moveTo(palm.x, palm.y);
          ctx.lineTo(
            palm.x + Math.cos(angle) * len,
            palm.y + Math.sin(angle) * len
          );
          ctx.stroke();
        }

        // ═══════════════════════════════════════════
        // FINGERTIP CONNECTIONS — web between fingers
        // ═══════════════════════════════════════════
        const tips = [4, 8, 12, 16, 20];
        ctx.strokeStyle = `rgba(${baseColor.join(',')}, ${0.5 * intensity})`;
        ctx.lineWidth = 1;

        // Connect all fingertips to each other
        for (let i = 0; i < tips.length; i++) {
          for (let j = i + 1; j < tips.length; j++) {
            const p1 = pts[tips[i]];
            const p2 = pts[tips[j]];
            ctx.beginPath();
            ctx.moveTo(p1.x, p1.y);
            ctx.lineTo(p2.x, p2.y);
            ctx.stroke();
          }
        }

        // ═══════════════════════════════════════════
        // SKELETON with audio-reactive thickness
        // ═══════════════════════════════════════════
        const bones = [[0,1],[1,2],[2,3],[3,4],[0,5],[5,6],[6,7],[7,8],[5,9],[9,10],[10,11],[11,12],[9,13],[13,14],[14,15],[15,16],[13,17],[17,18],[18,19],[19,20],[0,17]];
        ctx.strokeStyle = `rgba(${baseColor.join(',')}, ${0.8})`;
        ctx.lineWidth = 1 + smoothLevel * 3;
        ctx.beginPath();
        bones.forEach(([a, b]) => {
          ctx.moveTo(pts[a].x, pts[a].y);
          ctx.lineTo(pts[b].x, pts[b].y);
        });
        ctx.stroke();

        // ═══════════════════════════════════════════
        // FINGERTIP DOTS — size pulses with audio
        // ═══════════════════════════════════════════
        tips.forEach((idx, i) => {
          const p = pts[idx];
          const size = 4 + (freqData ? freqData[i * 8] / 255 : 0.5) * 12;

          // Outer glow
          ctx.fillStyle = `rgba(${baseColor.join(',')}, 0.3)`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, size * 2, 0, Math.PI * 2);
          ctx.fill();

          // Inner dot
          ctx.fillStyle = `rgba(${baseColor.join(',')}, 0.9)`;
          ctx.beginPath();
          ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
          ctx.fill();
        });

        // ═══════════════════════════════════════════
        // TRAIL LINES from fingertips
        // ═══════════════════════════════════════════
        if (!trails[hi]) trails[hi] = tips.map(() => []);

        tips.forEach((idx, i) => {
          const p = pts[idx];
          const trail = trails[hi][i];

          // Add current point
          trail.push({ x: p.x, y: p.y, age: 0 });

          // Remove old points
          while (trail.length > 20) trail.shift();

          // Draw trail
          if (trail.length > 1) {
            ctx.beginPath();
            trail.forEach((pt, j) => {
              const alpha = (j / trail.length) * 0.5 * intensity;
              ctx.strokeStyle = `rgba(${baseColor.join(',')}, ${alpha})`;
              ctx.lineWidth = (j / trail.length) * 3;
              if (j === 0) ctx.moveTo(pt.x, pt.y);
              else ctx.lineTo(pt.x, pt.y);
            });
            ctx.stroke();
          }
        });

        // ═══════════════════════════════════════════
        // WRIST TO PALM LINE with frequency data
        // ═══════════════════════════════════════════
        const segments = 16;
        ctx.beginPath();
        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const x = wrist.x + (palm.x - wrist.x) * t;
          const y = wrist.y + (palm.y - wrist.y) * t;
          const offset = (freqData ? freqData[i * 4] / 255 : 0.5) * 15 * intensity;
          const perpX = -(palm.y - wrist.y) / 100;
          const perpY = (palm.x - wrist.x) / 100;

          if (i === 0) ctx.moveTo(x + perpX * offset, y + perpY * offset);
          else ctx.lineTo(x + perpX * offset, y + perpY * offset);
        }
        ctx.strokeStyle = `rgba(${baseColor.join(',')}, 0.6)`;
        ctx.lineWidth = 2;
        ctx.stroke();

        // ═══════════════════════════════════════════
        // DATA READOUT — minimal
        // ═══════════════════════════════════════════
        ctx.font = '9px IBM Plex Mono';
        ctx.fillStyle = `rgba(${baseColor.join(',')}, 0.6)`;
        ctx.fillText(
          `${isRight ? 'R' : 'L'}_${Math.round(palm.x)},${Math.round(palm.y)}`,
          palm.x + 40, palm.y - 40
        );
      });

      // ═══════════════════════════════════════════
      // BOTTOM WAVEFORM — subtle frequency visualization
      // ═══════════════════════════════════════════
      if (freqData && !isMuted) {
        const barCount = 64;
        const barWidth = W / barCount;

        for (let i = 0; i < barCount; i++) {
          const freqIdx = Math.floor(i * freqData.length / barCount / 2);
          const barHeight = (freqData[freqIdx] / 255) * 60;
          const alpha = 0.15 + (freqData[freqIdx] / 255) * 0.2;

          ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
          ctx.fillRect(i * barWidth, H - barHeight, barWidth - 1, barHeight);
        }
      }
    }

    // ═══════════════════════════════════════════════════════════════
    // INIT
    // ═══════════════════════════════════════════════════════════════
    async function init() {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;

      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 1280, height: 720 } });
      video.srcObject = stream;
      await video.play();

      const handsModel = new Hands({ locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${f}` });
      handsModel.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.5 });
      handsModel.onResults(r => {
        hands = r.multiHandLandmarks || [];
        handedness = (r.multiHandedness || []).map(h => h.label);
      });
      await handsModel.initialize();

      async function process() {
        await handsModel.send({ image: video });
        requestAnimationFrame(process);
      }
      process();

      initAudio();

      function loop() {
        draw();
        updateAudio();
        requestAnimationFrame(loop);
      }
      loop();
    }

    document.getElementById('start').addEventListener('click', () => {
      document.getElementById('start').classList.add('hide');
      document.getElementById('back').style.display = 'block';
      document.getElementById('info-panel').style.display = 'block';
      document.getElementById('status').style.display = 'block';
      init();
    });

    window.addEventListener('resize', () => {
      W = canvas.width = window.innerWidth;
      H = canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
