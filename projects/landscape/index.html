<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Landscape — PUBLICWORKS</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #1a1a1a;
      overflow-x: hidden;
      font-family: 'IBM Plex Mono', monospace;
    }

    #canvas-container {
      position: relative;
      width: 100vw;
      min-height: 100vh;
    }

    .slice {
      position: absolute;
      overflow: hidden;
      will-change: transform;
    }

    .slice img {
      position: absolute;
      max-width: none;
    }

    .slice.glitch-repeat {
      /* Handled by JS */
    }

    .slice.glitch-stretch img {
      /* Pixel stretch effect */
    }

    .slice.rgb-shift {
      /* RGB handled by filter */
    }

    .slice.blank {
      background: #f5f5f5;
    }

    /* Loading indicator */
    #loading {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #6E6E6E;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      z-index: 1000;
      transition: opacity 0.5s ease;
    }

    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    /* Back link */
    #back-link {
      position: fixed;
      top: 2rem;
      left: 2rem;
      font-size: 0.75rem;
      color: #6E6E6E;
      text-decoration: none;
      z-index: 100;
      mix-blend-mode: difference;
      transition: color 0.15s ease;
    }

    #back-link:hover {
      color: #fff;
    }

    /* Scroll hint */
    #scroll-hint {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      color: #6E6E6E;
      font-size: 0.625rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      z-index: 100;
      opacity: 1;
      transition: opacity 0.5s ease;
    }

    #scroll-hint.hidden {
      opacity: 0;
    }

    /* Depth indicator */
    #depth-indicator {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      color: #6E6E6E;
      font-size: 0.625rem;
      font-family: 'IBM Plex Mono', monospace;
      z-index: 100;
      mix-blend-mode: difference;
    }
  </style>
</head>
<body>
  <a href="../../" id="back-link">← PUBLICWORKS</a>
  <div id="loading">Loading landscapes...</div>
  <div id="scroll-hint">Scroll to explore</div>
  <div id="depth-indicator">Y:0000</div>
  <div id="canvas-container"></div>

  <script>
    (function() {
      'use strict';

      // ---------- Configuration ----------
      const CONFIG = {
        pexelsApiKey: 'btO65X761pJo6C66T3ekHHTuXucIvixeYrg00NqFi8WNVO2NCKplJ7FY',
        queries: ['landscape', 'mountains', 'sky', 'nature', 'fields', 'forest', 'ocean', 'sunset'],
        imagesPerQuery: 3,
        minSlices: 8,
        generateAhead: 1500,
        recycleDistance: 2000,
        parallaxLayers: 5,
        glitchChance: 0.3,
        blankChance: 0.05,
      };

      // ---------- State ----------
      const container = document.getElementById('canvas-container');
      const loading = document.getElementById('loading');
      const scrollHint = document.getElementById('scroll-hint');
      const depthIndicator = document.getElementById('depth-indicator');

      let images = [];
      let slices = [];
      let generatedHeight = 0;
      let sliceId = 0;
      let isLoading = true;
      let lastScrollY = 0;

      // ---------- Image Loading ----------
      async function fetchImages() {
        const allImages = [];

        for (const query of CONFIG.queries) {
          try {
            const response = await fetch(
              `https://api.pexels.com/v1/search?query=${query}&per_page=${CONFIG.imagesPerQuery}&orientation=landscape`,
              {
                headers: {
                  'Authorization': CONFIG.pexelsApiKey
                }
              }
            );

            if (!response.ok) continue;

            const data = await response.json();
            for (const photo of data.photos) {
              allImages.push({
                url: photo.src.large,
                width: photo.width,
                height: photo.height,
                color: photo.avg_color,
              });
            }
          } catch (e) {
            console.warn(`Failed to fetch ${query}:`, e);
          }
        }

        return allImages;
      }

      async function preloadImages(imageData) {
        const promises = imageData.map(data => {
          return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              data.element = img;
              data.loaded = true;
              resolve(data);
            };
            img.onerror = () => {
              data.loaded = false;
              resolve(data);
            };
            img.src = data.url;
          });
        });

        return Promise.all(promises);
      }

      // ---------- Slice Generation ----------
      function randomRange(min, max) {
        return Math.random() * (max - min) + min;
      }

      function pickRandom(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function generateSliceSize() {
        const roll = Math.random();

        // 70% horizontal strips
        const isHorizontal = roll < 0.7;

        let width, height;

        if (Math.random() < 0.2) {
          // Large
          width = randomRange(400, 700);
          height = isHorizontal ? randomRange(100, 250) : randomRange(300, 500);
        } else if (Math.random() < 0.5) {
          // Medium
          width = randomRange(200, 400);
          height = isHorizontal ? randomRange(60, 150) : randomRange(150, 300);
        } else {
          // Small
          width = randomRange(50, 200);
          height = isHorizontal ? randomRange(30, 80) : randomRange(80, 150);
        }

        return { width: Math.round(width), height: Math.round(height) };
      }

      function generateSlicePosition(sliceHeight) {
        const viewportWidth = window.innerWidth;

        // Cluster towards center with some randomness
        const centerBias = Math.random() < 0.6;
        let x;

        if (centerBias) {
          const center = viewportWidth / 2;
          x = center + (Math.random() - 0.5) * viewportWidth * 0.6;
        } else {
          x = Math.random() * viewportWidth;
        }

        // Vertical position within generation zone
        const y = generatedHeight + randomRange(0, 300);

        return {
          x: Math.round(x - sliceHeight / 2),
          y: Math.round(y)
        };
      }

      function createSliceElement(imageData, size, position, layer) {
        const slice = document.createElement('div');
        slice.className = 'slice';
        slice.dataset.id = sliceId++;
        slice.dataset.layer = layer;
        slice.dataset.baseY = position.y;

        // Random crop from source image
        const img = imageData.element.cloneNode();
        const sourceW = imageData.element.naturalWidth;
        const sourceH = imageData.element.naturalHeight;

        // Random crop position
        const cropX = Math.random() * (sourceW - size.width * 1.5);
        const cropY = Math.random() * (sourceH - size.height * 1.5);

        // Scale to fit slice
        const scale = Math.max(size.width / sourceW, size.height / sourceH) * randomRange(1.2, 2);

        img.style.width = `${sourceW * scale}px`;
        img.style.height = `${sourceH * scale}px`;
        img.style.left = `${-cropX * scale}px`;
        img.style.top = `${-cropY * scale}px`;

        slice.style.width = `${size.width}px`;
        slice.style.height = `${size.height}px`;
        slice.style.left = `${position.x}px`;
        slice.style.top = `${position.y}px`;
        slice.style.zIndex = layer;

        slice.appendChild(img);

        // Apply glitch effects
        applyGlitchEffects(slice, img, size);

        // Apply subtle animation
        applyAnimation(slice);

        return slice;
      }

      function createBlankSlice(size, position, layer) {
        const slice = document.createElement('div');
        slice.className = 'slice blank';
        slice.dataset.id = sliceId++;
        slice.dataset.layer = layer;
        slice.dataset.baseY = position.y;

        slice.style.width = `${size.width}px`;
        slice.style.height = `${size.height}px`;
        slice.style.left = `${position.x}px`;
        slice.style.top = `${position.y}px`;
        slice.style.zIndex = layer;

        // Slight variation in blank color
        const brightness = 240 + Math.floor(Math.random() * 15);
        slice.style.background = `rgb(${brightness}, ${brightness}, ${brightness})`;

        return slice;
      }

      function applyGlitchEffects(slice, img, size) {
        if (Math.random() > CONFIG.glitchChance) return;

        const effect = Math.random();

        if (effect < 0.35) {
          // Horizontal line repetition
          slice.classList.add('glitch-repeat');
          const repeatCount = Math.floor(randomRange(3, 12));
          const sliceHeight = Math.floor(size.height / repeatCount);

          slice.style.background = `repeating-linear-gradient(
            to bottom,
            transparent 0px,
            transparent ${sliceHeight - 1}px,
            rgba(0,0,0,0.1) ${sliceHeight - 1}px,
            rgba(0,0,0,0.1) ${sliceHeight}px
          )`;
        } else if (effect < 0.6) {
          // RGB channel shift
          slice.classList.add('rgb-shift');
          const shiftX = randomRange(-5, 5);
          const shiftY = randomRange(-3, 3);

          // Create RGB layers
          const redLayer = img.cloneNode();
          const blueLayer = img.cloneNode();

          redLayer.style.cssText = img.style.cssText;
          blueLayer.style.cssText = img.style.cssText;

          redLayer.style.filter = 'url(#red-channel)';
          redLayer.style.transform = `translate(${shiftX}px, ${shiftY}px)`;
          redLayer.style.mixBlendMode = 'screen';
          redLayer.style.opacity = '0.8';

          blueLayer.style.filter = 'url(#blue-channel)';
          blueLayer.style.transform = `translate(${-shiftX}px, ${-shiftY}px)`;
          blueLayer.style.mixBlendMode = 'screen';
          blueLayer.style.opacity = '0.8';

          img.style.filter = 'url(#green-channel)';
          img.style.mixBlendMode = 'screen';

          slice.appendChild(redLayer);
          slice.appendChild(blueLayer);
        } else if (effect < 0.8) {
          // Pixel column stretch
          slice.classList.add('glitch-stretch');
          const stretchWidth = randomRange(20, 80);
          const stretchX = randomRange(0, size.width - stretchWidth);

          const stretchOverlay = document.createElement('div');
          stretchOverlay.style.cssText = `
            position: absolute;
            left: ${stretchX}px;
            top: 0;
            width: ${stretchWidth}px;
            height: 100%;
            background: linear-gradient(90deg,
              transparent,
              ${pickRandom(['rgba(255,255,255,0.3)', 'rgba(0,0,0,0.2)', 'rgba(0,71,255,0.2)'])},
              transparent
            );
          `;
          slice.appendChild(stretchOverlay);
        } else {
          // Scanlines
          const scanlines = document.createElement('div');
          scanlines.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: repeating-linear-gradient(
              to bottom,
              transparent 0px,
              transparent 2px,
              rgba(0,0,0,0.1) 2px,
              rgba(0,0,0,0.1) 4px
            );
            pointer-events: none;
          `;
          slice.appendChild(scanlines);
        }
      }

      function applyAnimation(slice) {
        if (Math.random() > 0.3) return;

        const animation = Math.random();

        if (animation < 0.5) {
          // Slow drift
          const driftX = randomRange(-30, 30);
          const driftY = randomRange(-20, 20);
          const duration = randomRange(15, 30);

          slice.style.animation = `drift ${duration}s ease-in-out infinite alternate`;
          slice.style.setProperty('--drift-x', `${driftX}px`);
          slice.style.setProperty('--drift-y', `${driftY}px`);
        } else {
          // Scale breathing
          const duration = randomRange(10, 20);
          slice.style.animation = `breathe ${duration}s ease-in-out infinite`;
        }
      }

      function generateSlices(targetHeight) {
        if (images.length === 0) return;

        while (generatedHeight < targetHeight) {
          const loadedImages = images.filter(img => img.loaded && img.element);
          if (loadedImages.length === 0) return;

          // Generate a batch of slices
          const batchSize = Math.floor(randomRange(3, 8));

          for (let i = 0; i < batchSize; i++) {
            const size = generateSliceSize();
            const position = generateSlicePosition(size.height);
            const layer = Math.floor(Math.random() * CONFIG.parallaxLayers) + 1;

            let slice;

            if (Math.random() < CONFIG.blankChance) {
              slice = createBlankSlice(size, position, layer);
            } else {
              const imageData = pickRandom(loadedImages);
              slice = createSliceElement(imageData, size, position, layer);
            }

            container.appendChild(slice);
            slices.push(slice);
          }

          generatedHeight += randomRange(150, 350);
        }

        // Update container height
        container.style.height = `${generatedHeight + window.innerHeight}px`;
      }

      function recycleSlices() {
        const scrollY = window.scrollY;
        const recycleThreshold = scrollY - CONFIG.recycleDistance;

        slices = slices.filter(slice => {
          const baseY = parseFloat(slice.dataset.baseY);
          if (baseY < recycleThreshold) {
            slice.remove();
            return false;
          }
          return true;
        });
      }

      // ---------- Parallax ----------
      function updateParallax() {
        const scrollY = window.scrollY;

        slices.forEach(slice => {
          const layer = parseInt(slice.dataset.layer);
          const baseY = parseFloat(slice.dataset.baseY);

          // Layers 1-5: slower to faster
          const parallaxSpeed = 0.5 + (layer / CONFIG.parallaxLayers) * 0.5;
          const offsetY = (scrollY - baseY) * (1 - parallaxSpeed);

          slice.style.transform = `translateY(${offsetY}px)`;
        });

        // Update depth indicator
        depthIndicator.textContent = `Y:${String(Math.round(scrollY)).padStart(4, '0')}`;
      }

      // ---------- Scroll Handler ----------
      let scrollTimeout;
      function onScroll() {
        const scrollY = window.scrollY;

        // Hide scroll hint after first scroll
        if (scrollY > 50) {
          scrollHint.classList.add('hidden');
        }

        // Generate more content if needed
        const viewportBottom = scrollY + window.innerHeight;
        if (viewportBottom + CONFIG.generateAhead > generatedHeight) {
          generateSlices(viewportBottom + CONFIG.generateAhead * 2);
        }

        // Parallax update
        updateParallax();

        // Debounced recycling
        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(recycleSlices, 200);

        lastScrollY = scrollY;
      }

      // ---------- SVG Filters for RGB Split ----------
      function createSVGFilters() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.style.cssText = 'position: absolute; width: 0; height: 0;';
        svg.innerHTML = `
          <defs>
            <filter id="red-channel">
              <feColorMatrix type="matrix" values="1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0"/>
            </filter>
            <filter id="green-channel">
              <feColorMatrix type="matrix" values="0 0 0 0 0  0 1 0 0 0  0 0 0 0 0  0 0 0 1 0"/>
            </filter>
            <filter id="blue-channel">
              <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0"/>
            </filter>
          </defs>
        `;
        document.body.appendChild(svg);
      }

      // ---------- CSS Animations ----------
      function injectAnimations() {
        const style = document.createElement('style');
        style.textContent = `
          @keyframes drift {
            from {
              transform: translate(0, 0);
            }
            to {
              transform: translate(var(--drift-x, 0), var(--drift-y, 0));
            }
          }

          @keyframes breathe {
            0%, 100% {
              transform: scale(1);
            }
            50% {
              transform: scale(1.02);
            }
          }
        `;
        document.head.appendChild(style);
      }

      // ---------- Initialize ----------
      async function init() {
        createSVGFilters();
        injectAnimations();

        // Fetch and preload images
        const imageData = await fetchImages();

        if (imageData.length === 0) {
          loading.textContent = 'Failed to load images';
          return;
        }

        images = await preloadImages(imageData);
        const loadedCount = images.filter(img => img.loaded).length;

        if (loadedCount < CONFIG.minSlices) {
          loading.textContent = 'Not enough images loaded';
          return;
        }

        isLoading = false;
        loading.classList.add('hidden');

        // Generate initial slices
        generateSlices(window.innerHeight * 2);

        // Set up scroll listener
        window.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', () => {
          generateSlices(window.scrollY + window.innerHeight + CONFIG.generateAhead);
        });

        // Initial parallax
        updateParallax();
      }

      init();
    })();
  </script>
</body>
</html>
