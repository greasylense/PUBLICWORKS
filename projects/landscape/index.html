<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Landscape — PUBLICWORKS</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      background: #0a0a0a;
      overflow-x: hidden;
      font-family: 'IBM Plex Mono', monospace;
      cursor: crosshair;
    }

    #canvas-container {
      position: relative;
      width: 100vw;
      min-height: 100vh;
    }

    .slice {
      position: absolute;
      overflow: hidden;
      will-change: transform, filter;
      backface-visibility: hidden;
    }

    .slice img {
      position: absolute;
      max-width: none;
      pointer-events: none;
    }

    .slice.corrupt {
      mix-blend-mode: screen;
    }

    .slice.invert {
      filter: invert(1);
    }

    .slice.blur {
      filter: blur(2px);
    }

    .slice.high-contrast {
      filter: contrast(2) saturate(1.5);
    }

    .slice.desaturate {
      filter: grayscale(1) contrast(1.2);
    }

    .slice.hue-shift {
      filter: hue-rotate(180deg) saturate(2);
    }

    /* Chromatic aberration layers */
    .chroma-r, .chroma-g, .chroma-b {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }

    .chroma-r { mix-blend-mode: lighten; }
    .chroma-g { mix-blend-mode: lighten; }
    .chroma-b { mix-blend-mode: lighten; }

    /* Data corruption overlay */
    .data-corrupt {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: repeating-linear-gradient(
        0deg,
        transparent,
        transparent 2px,
        rgba(255,255,255,0.03) 2px,
        rgba(255,255,255,0.03) 4px
      );
      pointer-events: none;
    }

    /* Tear effect */
    .tear {
      position: absolute;
      background: linear-gradient(90deg,
        transparent,
        rgba(255,255,255,0.8),
        transparent
      );
      height: 1px;
      pointer-events: none;
    }

    /* Loading */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #0a0a0a;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      transition: opacity 0.8s ease;
    }

    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #loading-text {
      color: #333;
      font-size: 0.625rem;
      text-transform: uppercase;
      letter-spacing: 0.2em;
    }

    #loading-bar {
      width: 200px;
      height: 1px;
      background: #222;
      margin-top: 1rem;
      position: relative;
      overflow: hidden;
    }

    #loading-progress {
      position: absolute;
      top: 0;
      left: 0;
      height: 100%;
      background: #fff;
      width: 0%;
      transition: width 0.3s ease;
    }

    /* Back link */
    #back-link {
      position: fixed;
      top: 2rem;
      left: 2rem;
      font-size: 0.75rem;
      color: #444;
      text-decoration: none;
      z-index: 100;
      transition: color 0.15s ease;
      mix-blend-mode: difference;
    }

    #back-link:hover {
      color: #fff;
    }

    /* Coordinates */
    #coords {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      color: #333;
      font-size: 0.5rem;
      font-family: 'IBM Plex Mono', monospace;
      z-index: 100;
      text-align: right;
      line-height: 1.6;
      mix-blend-mode: difference;
    }

    /* Vignette */
    #vignette {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 50;
      background: radial-gradient(ellipse at center, transparent 0%, transparent 50%, rgba(0,0,0,0.8) 100%);
    }

    /* Noise overlay */
    #noise {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 51;
      opacity: 0.04;
      background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.9' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%' height='100%' filter='url(%23noise)'/%3E%3C/svg%3E");
    }

    /* Scanlines */
    #scanlines {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      pointer-events: none;
      z-index: 52;
      background: repeating-linear-gradient(
        to bottom,
        transparent 0px,
        transparent 2px,
        rgba(0,0,0,0.15) 2px,
        rgba(0,0,0,0.15) 4px
      );
    }

    /* Glitch flash */
    @keyframes glitch-flash {
      0%, 100% { opacity: 0; }
      50% { opacity: 1; }
    }

    .glitch-flash {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #fff;
      pointer-events: none;
      z-index: 100;
      opacity: 0;
    }

    /* Horizontal tear animation */
    @keyframes tear-glitch {
      0%, 100% { transform: translateX(0); }
      25% { transform: translateX(-10px); }
      75% { transform: translateX(10px); }
    }

    /* Cursor ripple effect */
    .cursor-ripple {
      position: fixed;
      border-radius: 50%;
      pointer-events: none;
      z-index: 200;
      border: 1px solid rgba(255, 255, 255, 0.6);
      animation: ripple-expand 0.8s ease-out forwards;
    }

    @keyframes ripple-expand {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
      }
    }

    /* Distortion field around cursor */
    .distortion-field {
      position: fixed;
      width: 300px;
      height: 300px;
      pointer-events: none;
      z-index: 150;
      transform: translate(-50%, -50%);
      background: radial-gradient(circle, rgba(255,255,255,0.03) 0%, transparent 70%);
      mix-blend-mode: overlay;
    }

    /* Slice being dragged */
    .slice.dragging {
      z-index: 1000 !important;
      cursor: grabbing !important;
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      transition: none !important;
    }

    .slice.hoverable:hover {
      cursor: grab;
    }

    /* Revealed hidden layer */
    .hidden-layer {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .hidden-layer.revealed {
      opacity: 1;
    }

    /* Click shockwave */
    .shockwave {
      position: fixed;
      pointer-events: none;
      z-index: 300;
      animation: shockwave-expand 0.6s ease-out forwards;
    }

    @keyframes shockwave-expand {
      0% {
        transform: translate(-50%, -50%) scale(0);
        opacity: 1;
        border-width: 3px;
      }
      100% {
        transform: translate(-50%, -50%) scale(1);
        opacity: 0;
        border-width: 1px;
      }
    }
  </style>
</head>
<body>
  <a href="../../" id="back-link">← PUBLICWORKS</a>

  <div id="loading">
    <div id="loading-text">Fragmenting reality</div>
    <div id="loading-bar"><div id="loading-progress"></div></div>
  </div>

  <div id="coords">
    <div>DEPTH: <span id="depth">0000</span></div>
    <div>FRAGS: <span id="frags">000</span></div>
  </div>

  <div id="canvas-container"></div>
  <div id="vignette"></div>
  <div id="noise"></div>
  <div id="scanlines"></div>
  <div class="glitch-flash" id="flash"></div>
  <div class="distortion-field" id="distortion-field"></div>

  <script>
    (function() {
      'use strict';

      // ---------- Configuration ----------
      const CONFIG = {
        pexelsApiKey: 'btO65X761pJo6C66T3ekHHTuXucIvixeYrg00NqFi8WNVO2NCKplJ7FY',
        queries: ['landscape dramatic', 'mountains fog', 'stormy sky', 'aurora borealis', 'desert dunes', 'ocean waves', 'forest mist', 'volcanic', 'glacier ice', 'canyon'],
        imagesPerQuery: 4,
        generateAhead: 2000,
        recycleDistance: 3000,
        parallaxLayers: 7,
        baseGlitchChance: 0.5,
        corruptionIntensity: 0.7,
      };

      // ---------- State ----------
      const container = document.getElementById('canvas-container');
      const loading = document.getElementById('loading');
      const loadingProgress = document.getElementById('loading-progress');
      const depthEl = document.getElementById('depth');
      const fragsEl = document.getElementById('frags');
      const flash = document.getElementById('flash');
      const distortionField = document.getElementById('distortion-field');

      let images = [];
      let slices = [];
      let generatedHeight = 0;
      let sliceId = 0;
      let totalFragments = 0;

      // Interactive state
      let mouseX = 0;
      let mouseY = 0;
      let isMouseDown = false;
      let draggedSlice = null;
      let dragOffsetX = 0;
      let dragOffsetY = 0;
      let lastRippleTime = 0;
      const REPULSION_RADIUS = 200;
      const REPULSION_STRENGTH = 80;

      // ---------- Utility ----------
      function rand(min, max) {
        return Math.random() * (max - min) + min;
      }

      function randInt(min, max) {
        return Math.floor(rand(min, max + 1));
      }

      function pick(arr) {
        return arr[Math.floor(Math.random() * arr.length)];
      }

      function chance(probability) {
        return Math.random() < probability;
      }

      // ---------- Image Loading ----------
      async function fetchImages() {
        const allImages = [];
        let loaded = 0;
        const total = CONFIG.queries.length;

        for (const query of CONFIG.queries) {
          try {
            const response = await fetch(
              `https://api.pexels.com/v1/search?query=${encodeURIComponent(query)}&per_page=${CONFIG.imagesPerQuery}&orientation=landscape`,
              { headers: { 'Authorization': CONFIG.pexelsApiKey } }
            );

            if (response.ok) {
              const data = await response.json();
              for (const photo of data.photos) {
                allImages.push({
                  url: photo.src.large2x || photo.src.large,
                  width: photo.width,
                  height: photo.height,
                  color: photo.avg_color,
                });
              }
            }
          } catch (e) {
            console.warn(`Failed: ${query}`);
          }

          loaded++;
          loadingProgress.style.width = `${(loaded / total) * 50}%`;
        }

        return allImages;
      }

      async function preloadImages(imageData) {
        let loaded = 0;
        const total = imageData.length;

        const promises = imageData.map(data => {
          return new Promise((resolve) => {
            const img = new Image();
            img.crossOrigin = 'anonymous';
            img.onload = () => {
              data.element = img;
              data.loaded = true;
              loaded++;
              loadingProgress.style.width = `${50 + (loaded / total) * 50}%`;
              resolve(data);
            };
            img.onerror = () => {
              data.loaded = false;
              loaded++;
              resolve(data);
            };
            img.src = data.url;
          });
        });

        return Promise.all(promises);
      }

      // ---------- Slice Creation ----------
      function createSlice(imageData, config) {
        const slice = document.createElement('div');
        slice.className = 'slice';
        slice.dataset.id = sliceId++;
        slice.dataset.layer = config.layer;
        slice.dataset.baseY = config.y;

        // Clone and position image
        const img = imageData.element.cloneNode();
        const srcW = imageData.element.naturalWidth;
        const srcH = imageData.element.naturalHeight;

        // Random dramatic crop
        const scale = rand(1.5, 4);
        const cropX = rand(0, Math.max(0, srcW - config.width / scale));
        const cropY = rand(0, Math.max(0, srcH - config.height / scale));

        img.style.width = `${srcW * scale}px`;
        img.style.height = `${srcH * scale}px`;
        img.style.left = `${-cropX * scale}px`;
        img.style.top = `${-cropY * scale}px`;

        slice.style.cssText = `
          width: ${config.width}px;
          height: ${config.height}px;
          left: ${config.x}px;
          top: ${config.y}px;
          z-index: ${config.layer};
          opacity: ${config.opacity};
        `;

        slice.appendChild(img);

        // Apply effects
        applyArtisticEffects(slice, img, config, imageData);

        return slice;
      }

      function applyArtisticEffects(slice, img, config, imageData) {
        const effects = [];

        // Chromatic aberration - dramatic RGB split
        if (chance(0.25)) {
          createChromaticAberration(slice, img, config);
          effects.push('chroma');
        }

        // Horizontal displacement / databending
        if (chance(0.2)) {
          createDataBend(slice, config);
          effects.push('databend');
        }

        // Pixel sorting simulation
        if (chance(0.15)) {
          createPixelSort(slice, img, config);
          effects.push('pixelsort');
        }

        // Slice duplication / echo
        if (chance(0.2)) {
          createEchoEffect(slice, img, config);
          effects.push('echo');
        }

        // Tear lines
        if (chance(0.3)) {
          createTearLines(slice, config);
          effects.push('tears');
        }

        // Color manipulation
        if (chance(0.4)) {
          const colorEffect = pick(['invert', 'high-contrast', 'desaturate', 'hue-shift', 'blur']);
          slice.classList.add(colorEffect);
          effects.push(colorEffect);
        }

        // Blend mode corruption
        if (chance(0.15)) {
          slice.style.mixBlendMode = pick(['screen', 'multiply', 'overlay', 'difference', 'exclusion', 'color-dodge']);
          effects.push('blend');
        }

        // Rotation for dramatic angles
        if (chance(0.25)) {
          const rotation = pick([
            rand(-3, 3),      // Subtle tilt
            rand(-15, 15),    // Medium angle
            rand(85, 95),     // Near vertical
            rand(-95, -85),   // Near vertical other way
            180,              // Upside down
          ]);
          slice.style.transform = `rotate(${rotation}deg)`;
          effects.push('rotate');
        }

        // Clip path for irregular shapes
        if (chance(0.2)) {
          const clipPath = pick([
            `polygon(0 0, 100% ${randInt(0, 30)}%, 100% 100%, 0 ${randInt(70, 100)}%)`,
            `polygon(${randInt(0, 20)}% 0, 100% 0, ${randInt(80, 100)}% 100%, 0 100%)`,
            `polygon(0 0, 100% 0, 100% ${randInt(50, 100)}%, ${randInt(0, 50)}% 100%, 0 ${randInt(50, 100)}%)`,
            `inset(${randInt(0, 10)}% ${randInt(0, 5)}% ${randInt(0, 10)}% ${randInt(0, 5)}%)`,
          ]);
          slice.style.clipPath = clipPath;
          effects.push('clip');
        }

        // Subtle animation
        if (chance(0.3)) {
          const duration = rand(20, 60);
          const type = pick(['drift', 'pulse', 'flicker']);

          if (type === 'drift') {
            slice.style.animation = `drift ${duration}s ease-in-out infinite alternate`;
            slice.style.setProperty('--drift-x', `${rand(-50, 50)}px`);
            slice.style.setProperty('--drift-y', `${rand(-30, 30)}px`);
          } else if (type === 'pulse') {
            slice.style.animation = `pulse ${duration}s ease-in-out infinite`;
          } else {
            slice.style.animation = `flicker ${rand(0.1, 0.5)}s steps(2) infinite`;
          }
        }

        slice.dataset.effects = effects.join(',');
      }

      function createChromaticAberration(slice, img, config) {
        const intensity = rand(5, 25);
        const angle = rand(0, Math.PI * 2);

        // Red channel
        const rLayer = document.createElement('div');
        rLayer.className = 'chroma-r';
        rLayer.style.cssText = `
          background: inherit;
          transform: translate(${Math.cos(angle) * intensity}px, ${Math.sin(angle) * intensity}px);
          filter: url(#red-channel) brightness(1.1);
        `;
        const rImg = img.cloneNode();
        rImg.style.cssText = img.style.cssText;
        rImg.style.filter = 'grayscale(1) sepia(1) saturate(10000%) hue-rotate(-50deg)';
        rLayer.appendChild(rImg);

        // Blue channel
        const bLayer = document.createElement('div');
        bLayer.className = 'chroma-b';
        bLayer.style.cssText = `
          background: inherit;
          transform: translate(${Math.cos(angle + Math.PI) * intensity}px, ${Math.sin(angle + Math.PI) * intensity}px);
          filter: url(#blue-channel) brightness(1.1);
        `;
        const bImg = img.cloneNode();
        bImg.style.cssText = img.style.cssText;
        bImg.style.filter = 'grayscale(1) sepia(1) saturate(10000%) hue-rotate(180deg)';
        bLayer.appendChild(bImg);

        img.style.filter = 'grayscale(1) sepia(1) saturate(10000%) hue-rotate(50deg)';
        img.style.mixBlendMode = 'lighten';

        slice.appendChild(rLayer);
        slice.appendChild(bLayer);
        slice.style.background = '#000';
      }

      function createDataBend(slice, config) {
        const numBends = randInt(3, 12);

        for (let i = 0; i < numBends; i++) {
          const bend = document.createElement('div');
          const y = rand(0, config.height);
          const height = rand(1, 20);
          const offset = rand(-100, 100);

          bend.style.cssText = `
            position: absolute;
            left: ${offset}px;
            top: ${y}px;
            width: calc(100% + ${Math.abs(offset) * 2}px);
            height: ${height}px;
            background: ${pick([
              'rgba(255,255,255,0.8)',
              'rgba(0,255,255,0.5)',
              'rgba(255,0,255,0.5)',
              'rgba(255,255,0,0.5)',
              '#000',
              imageData => imageData.color
            ])};
            mix-blend-mode: ${pick(['difference', 'exclusion', 'overlay', 'screen'])};
          `;
          slice.appendChild(bend);
        }
      }

      function createPixelSort(slice, img, config) {
        // Simulate pixel sorting with gradient overlays
        const sortOverlay = document.createElement('div');
        const direction = pick(['to right', 'to bottom', 'to top', '45deg']);
        const startPos = rand(0, 70);

        sortOverlay.style.cssText = `
          position: absolute;
          top: 0;
          left: 0;
          right: 0;
          bottom: 0;
          background: linear-gradient(${direction},
            transparent ${startPos}%,
            rgba(0,0,0,0.3) ${startPos + 5}%,
            rgba(255,255,255,0.1) ${startPos + 10}%,
            transparent ${startPos + 30}%
          );
          mix-blend-mode: overlay;
          pointer-events: none;
        `;
        slice.appendChild(sortOverlay);

        // Add stretched pixel columns
        const numColumns = randInt(2, 8);
        for (let i = 0; i < numColumns; i++) {
          const col = document.createElement('div');
          const x = rand(0, config.width);
          const width = rand(1, 5);

          col.style.cssText = `
            position: absolute;
            left: ${x}px;
            top: 0;
            width: ${width}px;
            height: 100%;
            background: linear-gradient(to bottom,
              ${pick(['#fff', '#000', 'cyan', 'magenta', 'yellow'])} 0%,
              transparent 100%
            );
            opacity: ${rand(0.3, 0.8)};
            mix-blend-mode: screen;
          `;
          slice.appendChild(col);
        }
      }

      function createEchoEffect(slice, img, config) {
        const numEchoes = randInt(2, 6);
        const direction = { x: rand(-1, 1), y: rand(-1, 1) };

        for (let i = 1; i <= numEchoes; i++) {
          const echo = document.createElement('div');
          echo.style.cssText = `
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            transform: translate(${direction.x * i * rand(5, 15)}px, ${direction.y * i * rand(5, 15)}px);
            opacity: ${1 - (i / (numEchoes + 1))};
            mix-blend-mode: ${pick(['screen', 'lighten', 'overlay'])};
          `;
          const echoImg = img.cloneNode();
          echoImg.style.cssText = img.style.cssText;
          echo.appendChild(echoImg);
          slice.insertBefore(echo, slice.firstChild);
        }
      }

      function createTearLines(slice, config) {
        const numTears = randInt(1, 5);

        for (let i = 0; i < numTears; i++) {
          const tear = document.createElement('div');
          tear.className = 'tear';
          tear.style.cssText = `
            top: ${rand(0, config.height)}px;
            left: -10%;
            width: 120%;
            opacity: ${rand(0.5, 1)};
          `;
          slice.appendChild(tear);
        }
      }

      // ---------- Generation Algorithm ----------
      function generateComposition(targetHeight) {
        const loadedImages = images.filter(img => img.loaded && img.element);
        if (loadedImages.length === 0) return;

        while (generatedHeight < targetHeight) {
          // Decide composition type for this section
          const compositionType = pick([
            'scattered',
            'horizontal-band',
            'vertical-stack',
            'diagonal-cascade',
            'cluster',
            'sparse',
            'dense-chaos'
          ]);

          generateSection(compositionType, loadedImages);
          generatedHeight += rand(200, 600);
        }

        container.style.height = `${generatedHeight + window.innerHeight}px`;
        fragsEl.textContent = String(totalFragments).padStart(3, '0');
      }

      function generateSection(type, loadedImages) {
        const viewportWidth = window.innerWidth;
        const sectionY = generatedHeight;

        switch(type) {
          case 'scattered':
            generateScattered(sectionY, viewportWidth, loadedImages, randInt(4, 10));
            break;
          case 'horizontal-band':
            generateHorizontalBand(sectionY, viewportWidth, loadedImages);
            break;
          case 'vertical-stack':
            generateVerticalStack(sectionY, viewportWidth, loadedImages);
            break;
          case 'diagonal-cascade':
            generateDiagonalCascade(sectionY, viewportWidth, loadedImages);
            break;
          case 'cluster':
            generateCluster(sectionY, viewportWidth, loadedImages);
            break;
          case 'sparse':
            generateScattered(sectionY, viewportWidth, loadedImages, randInt(1, 3));
            break;
          case 'dense-chaos':
            generateScattered(sectionY, viewportWidth, loadedImages, randInt(12, 20));
            break;
        }
      }

      function generateScattered(baseY, viewportWidth, loadedImages, count) {
        for (let i = 0; i < count; i++) {
          const width = pick([
            rand(30, 80),     // Tiny
            rand(80, 200),    // Small
            rand(200, 400),   // Medium
            rand(400, 700),   // Large
            rand(700, viewportWidth * 0.9), // Massive
          ]);

          const height = chance(0.7)
            ? rand(width * 0.2, width * 0.6)  // Horizontal strip
            : rand(width * 0.8, width * 2);   // Vertical or square

          const config = {
            width: Math.round(width),
            height: Math.round(Math.min(height, 800)),
            x: Math.round(rand(-width * 0.3, viewportWidth - width * 0.7)),
            y: Math.round(baseY + rand(0, 400)),
            layer: randInt(1, CONFIG.parallaxLayers),
            opacity: rand(0.6, 1),
          };

          addSlice(pick(loadedImages), config);
        }
      }

      function generateHorizontalBand(baseY, viewportWidth, loadedImages) {
        const bandHeight = rand(100, 300);
        const numSlices = randInt(3, 8);
        let x = rand(-100, 0);

        for (let i = 0; i < numSlices; i++) {
          const width = rand(viewportWidth / numSlices * 0.5, viewportWidth / numSlices * 1.5);

          const config = {
            width: Math.round(width),
            height: Math.round(bandHeight + rand(-50, 50)),
            x: Math.round(x),
            y: Math.round(baseY + rand(-30, 30)),
            layer: randInt(2, 5),
            opacity: rand(0.7, 1),
          };

          addSlice(pick(loadedImages), config);
          x += width * rand(0.6, 1.1);
        }
      }

      function generateVerticalStack(baseY, viewportWidth, loadedImages) {
        const stackX = rand(viewportWidth * 0.1, viewportWidth * 0.6);
        const stackWidth = rand(200, 500);
        let y = baseY;

        const numSlices = randInt(3, 7);
        for (let i = 0; i < numSlices; i++) {
          const height = rand(40, 150);

          const config = {
            width: Math.round(stackWidth + rand(-50, 50)),
            height: Math.round(height),
            x: Math.round(stackX + rand(-30, 30)),
            y: Math.round(y),
            layer: randInt(1, CONFIG.parallaxLayers),
            opacity: rand(0.5, 1),
          };

          addSlice(pick(loadedImages), config);
          y += height * rand(0.3, 0.9);
        }
      }

      function generateDiagonalCascade(baseY, viewportWidth, loadedImages) {
        const startX = chance(0.5) ? -100 : viewportWidth;
        const direction = startX < 0 ? 1 : -1;
        let x = startX;
        let y = baseY;

        const numSlices = randInt(4, 10);
        for (let i = 0; i < numSlices; i++) {
          const width = rand(100, 350);
          const height = rand(60, 200);

          const config = {
            width: Math.round(width),
            height: Math.round(height),
            x: Math.round(x),
            y: Math.round(y),
            layer: randInt(1, CONFIG.parallaxLayers),
            opacity: rand(0.6, 1),
          };

          addSlice(pick(loadedImages), config);

          x += direction * rand(80, 200);
          y += rand(30, 120);
        }
      }

      function generateCluster(baseY, viewportWidth, loadedImages) {
        const centerX = rand(viewportWidth * 0.2, viewportWidth * 0.8);
        const centerY = baseY + rand(50, 150);
        const numSlices = randInt(5, 15);

        for (let i = 0; i < numSlices; i++) {
          const angle = rand(0, Math.PI * 2);
          const distance = rand(0, 250);
          const width = rand(50, 300);
          const height = rand(30, 200);

          const config = {
            width: Math.round(width),
            height: Math.round(height),
            x: Math.round(centerX + Math.cos(angle) * distance - width / 2),
            y: Math.round(centerY + Math.sin(angle) * distance - height / 2),
            layer: randInt(1, CONFIG.parallaxLayers),
            opacity: rand(0.4, 1),
          };

          addSlice(pick(loadedImages), config);
        }
      }

      function addSlice(imageData, config) {
        // Occasionally add blank/corrupt rectangle instead
        if (chance(0.08)) {
          addCorruptBlock(config);
          return;
        }

        const slice = createSlice(imageData, config);

        // Store original rotation for interactive transforms
        const transform = slice.style.transform;
        const rotationMatch = transform ? transform.match(/rotate\([^)]+\)/) : null;
        if (rotationMatch) {
          slice.dataset.originalRotation = rotationMatch[0];
        }

        // Add hidden layer for click reveals (40% chance)
        if (chance(0.4)) {
          addHiddenLayer(slice);
        }

        // Make slice draggable
        slice.classList.add('hoverable');

        container.appendChild(slice);
        slices.push(slice);
        totalFragments++;
      }

      function addCorruptBlock(config) {
        const block = document.createElement('div');
        block.className = 'slice';
        block.dataset.layer = config.layer;
        block.dataset.baseY = config.y;

        const style = pick([
          { bg: '#fff', blend: 'difference' },
          { bg: '#000', blend: 'normal' },
          { bg: 'linear-gradient(45deg, #0ff, #f0f)', blend: 'screen' },
          { bg: 'repeating-linear-gradient(90deg, #fff 0px, #fff 2px, #000 2px, #000 4px)', blend: 'difference' },
          { bg: `rgb(${randInt(0,255)},${randInt(0,255)},${randInt(0,255)})`, blend: 'exclusion' },
        ]);

        block.style.cssText = `
          width: ${config.width}px;
          height: ${config.height}px;
          left: ${config.x}px;
          top: ${config.y}px;
          z-index: ${config.layer};
          background: ${style.bg};
          mix-blend-mode: ${style.blend};
          opacity: ${rand(0.3, 0.9)};
        `;

        container.appendChild(block);
        slices.push(block);
        totalFragments++;
      }

      // ---------- Scroll & Parallax ----------
      function updateParallax() {
        const scrollY = window.scrollY;
        // Just update depth display - transforms handled by animation loop
        depthEl.textContent = String(Math.round(scrollY)).padStart(4, '0');
      }

      function recycleSlices() {
        const scrollY = window.scrollY;

        slices = slices.filter(slice => {
          const baseY = parseFloat(slice.dataset.baseY) || 0;
          if (baseY < scrollY - CONFIG.recycleDistance) {
            slice.remove();
            return false;
          }
          return true;
        });
      }

      let scrollTimeout;
      function onScroll() {
        const scrollY = window.scrollY;
        const viewportBottom = scrollY + window.innerHeight;

        if (viewportBottom + CONFIG.generateAhead > generatedHeight) {
          generateComposition(viewportBottom + CONFIG.generateAhead * 2);
        }

        updateParallax();

        clearTimeout(scrollTimeout);
        scrollTimeout = setTimeout(recycleSlices, 300);

        // Random glitch flash on fast scroll
        if (Math.abs(scrollY - (window._lastScrollY || 0)) > 100 && chance(0.1)) {
          triggerGlitchFlash();
        }
        window._lastScrollY = scrollY;
      }

      function triggerGlitchFlash() {
        flash.style.animation = 'none';
        flash.offsetHeight; // Reflow
        flash.style.animation = 'glitch-flash 0.05s steps(1)';
      }

      // ---------- CSS Animations ----------
      function injectStyles() {
        const style = document.createElement('style');
        style.textContent = `
          @keyframes drift {
            from { transform: translate(0, 0); }
            to { transform: translate(var(--drift-x, 0), var(--drift-y, 0)); }
          }
          @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.8; transform: scale(1.02); }
          }
          @keyframes flicker {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
          }
        `;
        document.head.appendChild(style);
      }

      // ---------- Mouse/Touch Interactivity ----------
      function createRipple(x, y, size = 100, color = 'rgba(255,255,255,0.6)') {
        const ripple = document.createElement('div');
        ripple.className = 'cursor-ripple';
        ripple.style.cssText = `
          left: ${x}px;
          top: ${y}px;
          width: ${size}px;
          height: ${size}px;
          border-color: ${color};
        `;
        document.body.appendChild(ripple);
        setTimeout(() => ripple.remove(), 800);
      }

      function createShockwave(x, y) {
        const colors = ['#fff', '#0ff', '#f0f', '#ff0'];
        const numWaves = randInt(3, 6);

        for (let i = 0; i < numWaves; i++) {
          setTimeout(() => {
            const wave = document.createElement('div');
            wave.className = 'shockwave';
            const size = rand(150, 400);
            wave.style.cssText = `
              left: ${x}px;
              top: ${y}px;
              width: ${size}px;
              height: ${size}px;
              border: 2px solid ${pick(colors)};
              border-radius: ${chance(0.5) ? '50%' : '0'};
            `;
            document.body.appendChild(wave);
            setTimeout(() => wave.remove(), 600);
          }, i * 50);
        }
      }

      function updateDistortionField(x, y) {
        distortionField.style.left = `${x}px`;
        distortionField.style.top = `${y}px`;
      }

      function applyRepulsion(clientX, clientY) {
        const scrollY = window.scrollY;
        const mouseAbsY = clientY + scrollY;

        slices.forEach(slice => {
          if (slice === draggedSlice) return;

          const rect = slice.getBoundingClientRect();
          const sliceCenterX = rect.left + rect.width / 2;
          const sliceCenterY = rect.top + rect.height / 2;

          const dx = sliceCenterX - clientX;
          const dy = sliceCenterY - clientY;
          const distance = Math.sqrt(dx * dx + dy * dy);

          if (distance < REPULSION_RADIUS && distance > 0) {
            const force = (1 - distance / REPULSION_RADIUS) * REPULSION_STRENGTH;
            const angle = Math.atan2(dy, dx);

            const pushX = Math.cos(angle) * force;
            const pushY = Math.sin(angle) * force;

            // Store original position data if not set
            if (!slice.dataset.repelX) slice.dataset.repelX = '0';
            if (!slice.dataset.repelY) slice.dataset.repelY = '0';

            slice.dataset.repelX = pushX.toFixed(2);
            slice.dataset.repelY = pushY.toFixed(2);

            // Add glitch effects on strong repulsion
            if (force > REPULSION_STRENGTH * 0.6 && chance(0.05)) {
              slice.style.filter = `hue-rotate(${rand(-180, 180)}deg) saturate(${rand(1, 3)})`;
              setTimeout(() => {
                slice.style.filter = '';
              }, 100);
            }
          } else {
            // Smoothly return to original position
            const currentRepelX = parseFloat(slice.dataset.repelX || 0);
            const currentRepelY = parseFloat(slice.dataset.repelY || 0);
            slice.dataset.repelX = (currentRepelX * 0.9).toFixed(2);
            slice.dataset.repelY = (currentRepelY * 0.9).toFixed(2);
          }
        });
      }

      function updateSliceTransforms() {
        slices.forEach(slice => {
          const layer = parseInt(slice.dataset.layer) || 1;
          const baseY = parseFloat(slice.dataset.baseY) || 0;
          const repelX = parseFloat(slice.dataset.repelX || 0);
          const repelY = parseFloat(slice.dataset.repelY || 0);

          const scrollY = window.scrollY;
          const speed = 0.3 + (layer / CONFIG.parallaxLayers) * 0.7;
          const parallaxOffset = (scrollY - baseY) * (1 - speed);

          const currentTransform = slice.dataset.originalRotation || '';

          slice.style.transform = `translateY(${parallaxOffset}px) translate(${repelX}px, ${repelY}px) ${currentTransform}`;
        });
      }

      function addHiddenLayer(slice) {
        // Create a hidden glitch layer that can be revealed
        const hidden = document.createElement('div');
        hidden.className = 'hidden-layer';

        const effect = pick([
          `background: linear-gradient(${rand(0, 360)}deg, rgba(255,0,255,0.5), rgba(0,255,255,0.5))`,
          `background: repeating-linear-gradient(${randInt(0, 90)}deg, #fff 0px, #fff 2px, transparent 2px, transparent 4px)`,
          `background: radial-gradient(circle, rgba(255,255,255,0.8) 0%, transparent 70%)`,
          `background: conic-gradient(from ${rand(0, 360)}deg, #f00, #0f0, #00f, #f00)`,
        ]);

        hidden.style.cssText = `${effect}; mix-blend-mode: ${pick(['overlay', 'screen', 'difference', 'exclusion'])}`;
        slice.appendChild(hidden);
        slice.dataset.hasHiddenLayer = 'true';
      }

      function revealHiddenLayer(slice) {
        const hidden = slice.querySelector('.hidden-layer');
        if (hidden) {
          hidden.classList.add('revealed');
          setTimeout(() => {
            hidden.classList.remove('revealed');
          }, 500);
        }
      }

      function handleMouseMove(e) {
        mouseX = e.clientX;
        mouseY = e.clientY;

        updateDistortionField(mouseX, mouseY);

        // Create subtle ripples while moving
        const now = Date.now();
        if (now - lastRippleTime > 100 && chance(0.15)) {
          createRipple(mouseX, mouseY, rand(30, 60), `rgba(255,255,255,${rand(0.1, 0.3)})`);
          lastRippleTime = now;
        }

        // Apply repulsion effect to nearby slices
        applyRepulsion(mouseX, mouseY);
        updateSliceTransforms();

        // Handle dragging
        if (draggedSlice) {
          const newX = e.clientX - dragOffsetX;
          const newY = e.clientY - dragOffsetY + window.scrollY;
          draggedSlice.style.left = `${newX}px`;
          draggedSlice.style.top = `${newY}px`;
          draggedSlice.dataset.baseY = newY;
        }
      }

      function handleMouseDown(e) {
        isMouseDown = true;

        // Check if clicking on a slice
        const target = e.target.closest('.slice');
        if (target && !target.classList.contains('dragging')) {
          // Start dragging
          draggedSlice = target;
          const rect = target.getBoundingClientRect();
          dragOffsetX = e.clientX - rect.left;
          dragOffsetY = e.clientY - rect.top;
          target.classList.add('dragging');

          // Store original rotation if any
          const transform = target.style.transform;
          const rotationMatch = transform.match(/rotate\([^)]+\)/);
          if (rotationMatch) {
            target.dataset.originalRotation = rotationMatch[0];
          }
        }
      }

      function handleMouseUp(e) {
        isMouseDown = false;

        if (draggedSlice) {
          draggedSlice.classList.remove('dragging');
          draggedSlice = null;
        }
      }

      function handleClick(e) {
        // Don't trigger on drag end
        if (draggedSlice) return;

        const x = e.clientX;
        const y = e.clientY;

        // Create shockwave effect
        createShockwave(x, y);

        // Flash effect
        triggerGlitchFlash();

        // Reveal hidden layers in nearby slices
        const clickRadius = 150;
        slices.forEach(slice => {
          const rect = slice.getBoundingClientRect();
          const centerX = rect.left + rect.width / 2;
          const centerY = rect.top + rect.height / 2;
          const distance = Math.sqrt(Math.pow(x - centerX, 2) + Math.pow(y - centerY, 2));

          if (distance < clickRadius) {
            if (slice.dataset.hasHiddenLayer === 'true') {
              revealHiddenLayer(slice);
            }

            // Random glitch effect
            if (chance(0.3)) {
              const originalFilter = slice.style.filter;
              slice.style.filter = `invert(1) hue-rotate(${rand(0, 360)}deg)`;
              setTimeout(() => {
                slice.style.filter = originalFilter;
              }, 150);
            }
          }
        });
      }

      // Touch support
      function handleTouchStart(e) {
        const touch = e.touches[0];
        handleMouseDown({ clientX: touch.clientX, clientY: touch.clientY, target: document.elementFromPoint(touch.clientX, touch.clientY) });
      }

      function handleTouchMove(e) {
        e.preventDefault();
        const touch = e.touches[0];
        handleMouseMove({ clientX: touch.clientX, clientY: touch.clientY });
      }

      function handleTouchEnd(e) {
        handleMouseUp({});
        if (e.changedTouches.length > 0) {
          const touch = e.changedTouches[0];
          // Tap to reveal
          if (!draggedSlice) {
            handleClick({ clientX: touch.clientX, clientY: touch.clientY });
          }
        }
      }

      // ---------- SVG Filters ----------
      function createFilters() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.style.cssText = 'position:absolute;width:0;height:0;';
        svg.innerHTML = `
          <defs>
            <filter id="red-channel">
              <feColorMatrix type="matrix" values="1 0 0 0 0  0 0 0 0 0  0 0 0 0 0  0 0 0 1 0"/>
            </filter>
            <filter id="blue-channel">
              <feColorMatrix type="matrix" values="0 0 0 0 0  0 0 0 0 0  0 0 1 0 0  0 0 0 1 0"/>
            </filter>
          </defs>
        `;
        document.body.appendChild(svg);
      }

      // ---------- Initialize ----------
      async function init() {
        injectStyles();
        createFilters();

        const imageData = await fetchImages();
        if (imageData.length === 0) {
          document.getElementById('loading-text').textContent = 'Failed to load';
          return;
        }

        images = await preloadImages(imageData);
        const loadedCount = images.filter(img => img.loaded).length;

        if (loadedCount < 5) {
          document.getElementById('loading-text').textContent = 'Insufficient fragments';
          return;
        }

        // Hide loading
        loading.classList.add('hidden');

        // Generate initial composition
        generateComposition(window.innerHeight * 3);

        // Scroll events
        window.addEventListener('scroll', onScroll, { passive: true });
        window.addEventListener('resize', () => {
          generateComposition(window.scrollY + window.innerHeight + CONFIG.generateAhead);
        });

        // Mouse interactivity
        document.addEventListener('mousemove', handleMouseMove);
        document.addEventListener('mousedown', handleMouseDown);
        document.addEventListener('mouseup', handleMouseUp);
        document.addEventListener('click', handleClick);

        // Touch interactivity
        document.addEventListener('touchstart', handleTouchStart, { passive: false });
        document.addEventListener('touchmove', handleTouchMove, { passive: false });
        document.addEventListener('touchend', handleTouchEnd);

        // Animation loop for smooth repulsion decay
        function animationLoop() {
          updateSliceTransforms();
          requestAnimationFrame(animationLoop);
        }
        requestAnimationFrame(animationLoop);

        updateParallax();
      }

      init();
    })();
  </script>
</body>
</html>
